\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\input{prelude}
\input{ldef}
\usepackage{eucal}
\usepackage{url}
\usepackage{tikz}
\usepackage{amsfonts,amsmath}
\usepackage{hyperref}
\begin{document}

\title{Verifying Differential Privacy in Floating-Point Computation}
\author{}

\date{}
\maketitle
\begin{abstract}
The programs implementing differentially private algorithms can be formally verified via existing logics and tools, such as $\mathsf{apRHL}^+$\cite{barthe2016proving}. 
These verifications rely on the assumption that these implementations whose underlining computation is real number based without computation error.
However, in reality, these algorithms are mostly implemented under finite precision, which accounts for computation errors
and causes critical failures in preserving differential privacy. 

We develop a method for formally verifying differential privacy of algorithms implemented based on floating-point computation. Our method extends the relational program logic $\mathsf{apRHL}^+$, and provides an operational semantics under floating-point computation, which work together to provide the formal verification.

We demonstrate our method via an algorithm: the \emph{Snapping mechanism}  proposed in \cite{mironov2012significance}, where its  differential privacy is theoretically proved even with floating-point computation error.
We implement our logic and example verifications in Coq.
\end{abstract}

\section{Introduction}
Differential privacy proposed by Dwork, McSherry, Nissim, and Smith \cite{dwork2006calibrating} is considered the gold standard for privacy-preserving computations. 
%
Existing methods are able to formally verify the differential privacy of most of the popular algorithms \cite{barthe2016proving}. 
However, these verifications are based on the ideal implementations of these algorithms without computation error.
While in reality, the implementations of these algorithms are not ideal, mostly in floating-point computation with computation errors.
These computation errors can cause critical failures in preserving differential privacy, which is identified in the literature \cite{balcer2017differential, gazeau2016preserving, mckenna2020permute, mironov2012significance, ilvento2020implementing}.
%
In the meantime, some algorithms claim to preserve differential privacy even in floating-point computation, for instance:
\begin{itemize}
	\item The \emph{Snapping mechanism}, which is an improved version of the implementation of Laplace mechanism in floating-point computation, by adding extra rounding and clamping operations. (See \cite{mironov2012significance}.)
%
	\item The \emph{Base-2 Exponential mechanism}, which is a revised version of the Exponential mechanism, by altering the base in Exponential mechanism from $e$ into $2$. (See \cite{ilvento2020implementing}.)
%
	\item The \emph{Discrete Gaussian mechanism}, which is a discrete version of the Gaussian mechanism. (See \cite{canonne2020discrete}.)
\end{itemize}
%
Unfortunately, existing pen-and-paper proofs of these algorithms use complex computation error approximations, which are hard to understand and error-prone.

This gives us the motivation that can we develop methods for formally and automatically verifying these algorithms by considering the errors that arose during the floating-point computation.

To verify the differential privacy property of
the algorithms implemented in floating-point computation,
we extend the relational program logic $\mathsf{apRHL}^+$ from
\cite{barthe2016proving}. 
Then we compose 
it with an operational semantics designed for approximating the floating-point computation error.
%
We prove the soundness via the methodology of probabilistic coupling and approximate lifting shown by Barth et al. \cite{barthe2016proving}.
%
\section{System Overview}
We propose a formal analysis of differentially private algorithms under finite computation, whose proof does not exclusively rely on the existing tools of differential privacy. The paper is composed of three main components.
%
\paragraph{The language and operational semantics}
We firstly design an operational semantics for approximating the floating-point computation errors on a standard imperative language with only the assignment, distribution sampling, and sequence commands.

In this language, the expressions (in real number precision) are evaluated into floating-point values $\fval$ through floating-point computation with computation error arose during evaluation. 

In order to track the computation error propagated in floating-point computation, we attach a pair of real values $(\rval_1, \rval_2)$ to approximate the computation error in the environment for every variable. 
To be specific,
a variable is mapped to $(\fval_{(\rval_1, \rval_2)})$, where $\fval$ is a value evaluated from some expressions in floating-point precision,
and $\rval_1, \rval_2$ are lower and upper bounds of the floating-point computation error propagated when evaluating into $\fval$: 
$\trsmem, \expr \trsto \fval_{(\rval_1, \rval_2)}$.
%
For example, $[], 1 + 1 \trsto 2_{(1.99, 2.01)}$, where $\pm 0.01$ are the relative computation errors relevant to the machine epsilon $\eta$.

The operational semantics for programs takes an environment $\trsmem$ and a program $\prog$ and returns a distribution over environment $\trsmem'$: $\trsmem, \prog \trsto Distr(\trsmem')$. 
For example, $[], x \samplel \uniform(0,1] \trsto 
\elet 0.1_{(0.1, 0.1)} = \sem{\uniform(0,1]} \ein \unit{[x \mapsto 0.1_{(0.1, 0.1)}]}$, 
where we assume the sample from discrete floating-point numbers produce no error, accounting for the $0.1_{(0.1, 0.1)}$ in the environment.

%
\paragraph{An extended $\mathsf{apRHL}^+$} 
To verify the differential privacy, we adopt the proof principles of probabilistic coupling and approximate lifting and work with a relational program logic
$\mathsf{apRHL}^+$.

We conceive it as a floating-point computational variant of $\mathsf{apRHL}^+$ based on the new operational semantics, i.e., in the environments, variables are mapping to floating-point values together with their lower and upper bounds on computation errors, instead of a single real number.
%
The judgments are of the form:
$
\prog_1 \sim_{\epsilon} \prog_2: \Phi \Rightarrow \Psi
$,
where $\prog_1$ and $\prog_2$ are programs and $\Phi$ and $\Psi$ are assertions on pairs of the newly defined environments.
Each assertion refers to two copies $x\vtag{1}$, $\vtag{2}$ of each program variable $x$, where tagged variables refer to the value of x in executions of $\prog_1$ and $\prog_2$ respectively.
%
Different from $\mathsf{apRHL}^+$, each assertion can refer to any values to which the variables are mapped in the environment through annotations on the top right of variables. 
For example, $x^1$, $x^2$ and $x^3$ refer to $\fval, \rval_1$ and $\rval_2$ respectively 
if $x$ is mapped to $\fval_{(\rval_1, \rval_2)}$ in the environment.
%

Informally, a judgment of the above form is valid if the two distributions produced by the executions of 
$\prog_1$ and $\prog_2$ on any two initial memories satisfying the precondition $\Phi$ are related by the $\epsilon$-lifting (formally defined in \ref{def:lifting}) of the postcondition $\Psi$ in floating-point computation. 
% For example, $\mathsf{laplace}(\epsilon, v_1) $ and 
% $\mathsf{laplace}(\epsilon, v_2)$ are related by the $\epsilon$-lifting of the equivalent relation if $|v_1 - v_2| \leq 1$, 
% where $\mathsf{laplace}(\epsilon, v)$ is the Laplace distribution with scale $\epsilon$ and location $v$.
% 
% where $\mathsf{laplace}(\epsilon, v)$ is the Laplace distribution with scale $\epsilon$ and location $v$.
% A program is proved to be $\epsilon$-differentially private if their resulted distributions are related by the $\epsilon$-lifting on adjacent inputs.
%
For example, $\uniform(0, 1] $ and
$\uniform(0, 1]$ are related by the $\epsilon$-lifting of the relation $\Phi \triangleq \{(x, y) \in (0, 1]^{\float} \times (0, 1]^{\float} | x = e^{\epsilon}y\}$,
where $\uniform(0, 1] $ is the uniform distribution on floating-point numbers range over $(0, 1]$.
% Further, we introduce new proof rules representing the new computations beyond the pure real-number computation.
%

Further, we introduce new proof rules representing the approximate probabilistic liftings for the process of sampling from uniform distribution 
---the key component of implementing the Laplace mechanism in floating-point computation---
the \textbf{unif}:
\\
$
\inferrule
{
	\empty
}
{
	\vdash
	\varx \samplel \uniform(0, 1] 	
	\sim_{\epsilon} 
	\vary \samplel \uniform(0, 1]
	:
	\top
	\Rightarrow
	\varx^1 \langle 1 \rangle 
	= 
	e^{\epsilon} \vary^1 \langle 2 \rangle 	
}~\textbf{unif}
$
\\
and two corollary rules \textbf{unif+} and \textbf{unif-}:
\\
$\vdash
	\varx \samplel \uniform(0, 1] 	
	\sim_{\epsilon} 
	\vary \samplel \uniform(0, 1]
	:
	\top
	\Rightarrow
	\forall l, r \in [0,1]^{\real}. ~
	l \leq \varx^1 \langle 1 \rangle \leq r 
	\imply
	(e^{\epsilon} l \leq \vary^1 \vtag{2} \leq e^{\epsilon}r \land \vary^1 \vtag{2}\leq 1);	
$
\\
$\vdash
	\varx \samplel \uniform(0, 1] 	
	\sim_{\epsilon} 
	\vary \samplel \uniform(0, 1]
	:
	\top
	\Rightarrow
	\forall l, r \in [0,1]^{\real}. ~
	l \leq \varx^1 \langle 1 \rangle \leq r 
	\imply
	(e^{-\epsilon} l \leq \vary^1 \langle 2 \rangle \leq e^{-\epsilon}r \leq 1),
$
\\
These rules represent the $\epsilon$-lifting of two uniform distribution on floating-point numbers range over $(0, 1]$ w.r.t. to postconditions respectively.
%
%
%
Although this process itself is not differentially private, its properties can be formally captured by approximate probabilistic liftings and be combined to show privacy for a larger program.
%
\paragraph{New privacy proofs}
We provide the first formal verification of the \emph{Snapping mechanism}, which is a variant of the Laplace mechanism in floating-point computation with extra rounding and clamping operations. 
Its privacy proof is based on the floating-point computation error approximation, which cannot be formally verified by any of the existing tools. 
In contrast, we prove its privacy in floating-point computation within our logic.

We plan to formalize the language and the proof of the algorithm in Coq.

\section{Syntax}
The language is defined as follows.
\\
In the language, $\rval$ is in the domain of real number $\real$, $\rval \in \real$. 
$\fval$ is in the domain of floating point number $\float$, $\fval \in \float$. 
Furthermore, $\float$ is a subset of $\real$ allowing the $\fval$ be represented in $\real$ without lose of precision. 
On the other hand, $\rval$ sacrifices its precision when casted into $\float$.
The type $\float_{\real \times \real}$ represents the base type of values, composed of a floating-point value $\fval$ and a pair of real-number values $\rval$.
In environment., the variables are mapped to $(\fval_{(\rval, \rval)})$ of the type $\float_{\real \times \real}$.
%
\[\begin{array}{llll}
\mbox{Programs} & \prog & ::= &
	%
    \varx = \expr ~|~ \varx \samplel \edistr
	%
	~|~ \prog ; \prog  
	\extend{ ~|~ \eif \bexpr \ethen \prog \eelse \prog
		~|~ \ewhile \bexpr \edo \prog }\\
%
\mbox{Expr} & \expr & ::= & \rval
	%
	~|~ \varx  ~|~ \expr \bop \expr
	%
	~|~ \ln (\expr) ~|~ - \expr ~|~ \clamp_{\rval}(\expr)
	%
	~|~ \round{\expr}_{\rval}  \\
%
\mbox{Binary Operation} & \bop & ::= & + ~|~ - ~|~ \times ~|~ \div \\
%
\mbox{BExpr} & \bexpr & ::= & \extend{ \etrue ~|~ \efalse
	~|~ \expr < \expr
 	%
 	~|~ \expr = \expr  ~|~ \neg \bexpr
 	%
 	~|~ \bexpr \land \bexpr
 	%
 	~|~ \bexpr \lor \bexpr } \\
%
%
\mbox{Value} & \valv & ::= & \fval_{(\rval, \rval)}\\
%
\mbox{Distr} & \edistr & ::= & \uniform(0, 1]
%
	~|~ \uniform\{-1, 1\}\\ 
%
\mbox{Error} & \err & ::= & (\rval, \rval) \\
%
\mbox{Env} & \trsmem & ::= & \cdot ~|~ \trsmem[x \mapsto (\fval_{(\rval, \rval)})]\\
%
\mbox{Type} & \tau & ::= & \float ~|~ \real ~|~ \float_{\real \times \real}
\end{array}
\]


%
\paragraph{Semantics.}
$\boxed{Env \times Expr \to Value }$
%
\[
	\begin{array}{rcl}
	\sem{\expr}_{\trsmem}
	& \in &  
	\big\{\fval_{(\rval_{l}, \rval_{u})} ~|~
	\exists ~~  
	\trsmem,  
	\expr \trsto (\fvalv_{(\rval_{l}, \rval_{u})})\big\}
	\end{array}
\]
%
$\boxed{Env \times BExpr \to \big\{\etrue, \efalse \big\} }$
%
\extend{
\[
	\begin{array}{rcl}
	\sem{\expr_1 < \expr_2}_{\trsmem}
	& \triangleq &  
	\sem{\expr_1}_{\trsmem}^1 < \sem{\expr_2}_{\trsmem}^1\\
	\sem{\expr_1 = \expr_2}_{\trsmem}
	& \triangleq &  
	\sem{\expr_1}_{\trsmem}^1 < \sem{\expr_2}_{\trsmem}^1
	\end{array}
	%
	\hspace{2cm}
	%
	\begin{array}{rcl}
	\sem{ \neg \bexpr}_{\trsmem}
	& \triangleq &  
	\neg \sem{\bexpr}_{\trsmem}
	\\
	\sem{\bexpr_{1} \land \bexpr_{2}}_{\trsmem}
	& \triangleq &  
	\sem{\bexpr_{1}}_{\trsmem} \land \sem{\bexpr_{2}}_{\trsmem}
	\\
	\sem{\bexpr_{1} \lor \bexpr_{2}}_{\trsmem}
	& \triangleq &  
	\sem{\bexpr_{1}}_{\trsmem} \lor \sem{\bexpr_{2}}_{\trsmem}
	\end{array}
\]
}
%
$
\boxed{Env \times \distr \to 
\distr(Value)}
$
%
\[
	\begin{array}{rcl}
	\sem{\uniform(0, 1]}_{\trsmem}
	& \in & 
	\big\{
	(\fval_{(\rval_{l}, \rval_{u})}) ~|~
	\fval \leftarrow \muniform(0, 1]
	\land \rval_{l} = \rval_{u} = \fval
	\big\}\\
	\sem{\uniform\{-1, 1\}}_{\trsmem}
	& \in & 
	\big\{
	(-1_{(-1, -1)}), (1_{(1, 1)}) ~|~
	each ~ w.p. ~ 0.5 
	\big\}\\	
	\end{array}
\]
%
$\boxed{Env \times prog \to \distr(Env)}$
\[
\begin{array}{rcl}
	%
	\sem{\varx \samplel \edistr}_{\trsmem}
	& = & 
	\elet \fval_{(\rval_{l}, \rval_{u})} = \sem{\edistr}_{\trsmem}
	\ein 
	\unit{\trsmem[\varx \mapsto \fval_{(\rval_{l}, \rval_{u})}]}
	\\
	%
	\sem{\varx = \expr}_{\trsmem}
	& = &  
	~\unit{\trsmem[\varx \mapsto \sem{\expr}_{\trsmem}]}
	\\
	%
	\sem{\prog_1; \prog_2}_{\trsmem}
	& = &  \elet  \trsmem_1 = 
	\sem{\prog_1}_{\trsmem} \ein
	\sem{\prog_2}_{\trsmem_1} 
	\\
	%
	\extend{\sem{\eif \bexpr \ethen \prog_t \eelse \prog_f}_{\trsmem}}
	& = & 
	\left\{
	\begin{array}{ll}
	\sem{\prog_t}_{\trsmem} & : \sem{\bexpr}_{\trsmem} = \etrue \\
	\sem{\prog_f}_{\trsmem} & : \sem{\bexpr}_{\trsmem} = \efalse \\
	\end{array}
	\right .
	\\
	%
	\extend{\sem{\ewhile \bexpr \edo \prog}_{\trsmem}}
	& = &  
	\left\{
	\begin{array}{ll}
	\elet \trsmem' = \sem{\prog}_{\trsmem} \ein 
	\sem{\ewhile \bexpr \edo \prog}_{\trsmem'}
	  & : \sem{\bexpr}_{\trsmem} = \etrue \\
	\unit \trsmem & : \sem{\bexpr}_{\trsmem} = \efalse \\
	\end{array}
	\right .
\end{array}
\]
%
In the semantics, 
%
$\trsmem, \expr \trsto (\fvalv_{\err})$ represents given an environment
%
$\trsmem$, the expression $\expr$
%
is transited to $\fvalv$ with error bound $err = (\rval_{l}, \rval_{u})$
in floating point transition semantics,
%
s.t. $\rval_{l} \leq \fvalv \leq \rval_{u}$. The semantics is presented in Figure. \ref{fig:op_semantics}.
%
$\trsmem, \prog \trsto \trsmem'$ represents given and environment $\trsmem$,
%
the program $\prog$ is transited to a new environment $\trsmem'$.
%
The $\muniform(0, 1] \in \distr(\float)$ is the mathematic uniform distribution over floating point values ranging over $(0, 1]$.
%
%
\begin{figure}
\boxed{\trsmem, \expr \trsto \fval_{(\rval, \rval)}
: Env \times Expr \trsto Value}
\begin{mathpar}
\inferrule*[right = var]
{
	\trsmem(\varx) 
	= (\fval_{( \ubar{\rval}, \bar{\rval} )})
}
{
	\trsmem, \varx
	\trsto
	(\fval_{( \ubar{\rval}, \bar{\rval} )})
}
\and
%
\inferrule*[right = val]
{
	\fval = \floaten(\rval)
	~~
	\fval \neq \rval
	\and
	\rval \geq 0
}
{
	\trsmem, \rval
	\trsto
	\big(\fval_{(\frac{\rval}{(1 + \eta)}, \rval(1 + \eta))} 
	\big)
}
%
\and
%
\inferrule*[right = val-neg]
{
	\fval = \floaten(\rval) 
	~~
	\fval \neq \rval
	\and
	\rval < 0
}
{
	\trsmem, \rval
	\trsto
	\big(\fval_{(\rval(1 + \eta), \frac{\rval}{(1 + \eta)})} \big)
}
%
\and
%
\inferrule*[right = val-eq]
{
	\fval = \floaten(\rval)
	~~~~
	\fval = \rval
}
{
	\trsmem, \rval
	\trsto
	(\fval_{(\rval, \rval)} )
}
%
\and
%
\inferrule*[right = bop-pp]
{
	\trsmem, \expr_1 \trsto 
	(\fval_{1(\ubar{\rval_1}, \bar{\rval_1})})
	~~~~
	\trsmem, \expr_2 \trsto (\fval_{2(\ubar{\rval_2}, \bar{\rval_2})})
	~~~~
	\fval_1 \geq 0
	~~~~
	\fval_2 \geq 0
	~~~~
	\fval = \floaten(\fval_1 * \fval_2)
	~~~~
	* \in \{\times, \div \}
}
{
    \trsmem, \expr_1 * \expr_2
    \trsto
    \big(
    \fval_{(\frac{\ubar{\rval_1} * \ubar{\rval_2}}{(1 + \eta)}, 
        (\bar{\rval_1} * \bar{\rval_2})(1 + \eta))}
    \big)
}
%
\and
%
\inferrule*[right = bop-nn]
{
	\trsmem, \expr_1 \trsto (\fval_{1(\ubar{\rval_1}, \bar{\rval_1})})
	~~~~
	\trsmem, \expr_2 \trsto (\fval_{2(\ubar{\rval_2}, \bar{\rval_2})})
	~~~~
	\fval_1 < 0
	~~~~
	\fval_2 < 0
	~~~~
	\fval = \floaten(\fval_1 * \fval_2)
	~~~~
	* \in \{\times, \div \}
}
{
    \trsmem, \expr_1 * \expr_2
    \trsto
    \big(
    \fval_
    {(\frac{\bar{\rval_1} * \bar{\rval_2}}{(1 + \eta)}, 
        (\ubar{\rval_1} * \ubar{\rval_2})(1 + \eta))}
    \big)
}
%
\and
%
\inferrule*[right = bop-pn]
{
	\trsmem, \expr_1 \trsto (\fval_{1(\ubar{\rval_1}, \bar{\rval_1})})
	~~~~
	\trsmem, \expr_2 \trsto (\fval_{2(\ubar{\rval_2}, \bar{\rval_2})})
	~~~~
	\fval_1 \geq 0
	~~~~
	\fval_2 < 0
	~~~~
	\fval = \floaten(\fval_1 * \fval_2)
	~~~~
	* \in \{\times, \div \}
}
{
    \trsmem, \expr_1 * \expr_2
    \trsto
    \big(
    \fval_
    {((\bar{\rval_1} * \ubar{\rval_2})(1 + \eta),
        \frac{\ubar{\rval_1} * \bar{\rval_2}}{(1 + \eta)})}
    \big)
}
%
\and
%
\inferrule*[right = bop-np]
{
	\trsmem, \expr_1 \trsto (\fval_{1(\ubar{\rval_1}, \bar{\rval_1})})
	~~~~
	\trsmem, \expr_2 \trsto (\fval_{2(\ubar{\rval_2}, \bar{\rval_2})})
	~~~~
	\fval_1 < 0
	~~~~
	\fval_2 \geq 0
	~~~~
	\fval = \floaten(\fval_1 * \fval_2)
	~~~~
	* \in \{\times, \div \}
}
{
    \trsmem, \expr_1 * \expr_2
    \trsto
    \big(
    \fval_
    {((\ubar{\rval_1} * \bar{\rval_2})(1 + \eta),
        \frac{\bar{\rval_1} * \ubar{\rval_2}}{(1 + \eta)})}
    \big)
}
%
\and
%
\inferrule*[right = bop-p]
{
	\trsmem, \expr_1 \trsto (\fval_{1(\ubar{\rval_1}, \bar{\rval_1})})
	~~~~
	\trsmem, \expr_2 \trsto (\fval_{2(\ubar{\rval_2}, \bar{\rval_2})})
	~~~~
	\fval = \floaten(\fval_1 * \fval_2)
	~~~~
	\fval \geq 0
	~~~~
	* \in \{+, - \}
}
{
    \trsmem, \expr_1 * \expr_2
    \trsto
    \big(
    \fval_
    {(\frac{\ubar{\rval_1} * \ubar{\rval_2}}{(1 + \eta)}, 
            (\bar{\rval_1} * \bar{\rval_2})(1 + \eta))}
    \big)
}
%
\and
%
\inferrule*[right = bop-n]
{
	\trsmem, \expr_1 \trsto (\fval_{1(\ubar{\rval_1}, \bar{\rval_1})})
	~~~~
	\trsmem, \expr_2 \trsto (\fval_{2(\ubar{\rval_2}, \bar{\rval_2})})
	~~~~
	\fval = \floaten(\fval_1 * \fval_2)
	~~~~
	\fval < 0
	~~~~
	* \in \{+, - \}
}
{
    \trsmem, \expr_1 * \expr_2
    \trsto
    \big(
    \fval_
    {((\ubar{\rval_1} * \ubar{\rval_2})(1 + \eta),
            \frac{\bar{\rval_1} * \bar{\rval_2}}{(1 + \eta)})}
    \big)
}
%
\and
%
\inferrule*[right = uop-p]
{
	\trsmem, \expr \trsto (\fval_{1(\ubar{\rval}, \bar{\rval})})
	~~~~
	\fval = \floaten(\uop (\fval_1)) 
	~~~~
	\fval \geq 0
}
{
    \trsmem, \uop(\expr)
    \trsto
    \Big(\fval_
    {\big(
        \frac{\uop(\ubar{\rval})}{(1 + \eta)}, 
        (\uop(\bar{\rval}))(1 + \eta)
        \big)}
    \Big)
}
%
~~~~
%
\inferrule*[right = uop-n]
{
	\trsmem, \expr \trsto (\fval_{1(\ubar{\rval}, \bar{\rval})})
	~~~~
	\fval = \floaten(\uop (\fval_1)) 
	~~~~
	\fval < 0
}
{
    \trsmem, \uop(\expr)
    \trsto 
    \Big(\fval_
    {\big(\uop(\ubar{\rval})(1 + \eta),
        \frac{\uop(\bar{\rval})}{(1 + \eta)}
        \big)}
    \Big)
}
\end{mathpar}
\caption{Semantics of Transition for Expressions with Relative Floating Point Error}
\label{fig:op_semantics}
\end{figure}
%
%
\section{Judgement and Validity}
%
\begin{defn}
[$\epsilon-$lifting \cite{barthe2016proving}]
\label{def:lifting}
Two sub-distributions $\mu_1 \in \distr(\mathcal{D}_1)$, $\mu_2 \in \distr(\mathcal{D}_2)$ are related by the $\epsilon-$lifting of $\Psi \subseteq \mathcal{D}_1 \times \mathcal{D}_2$, written $\mu_1 \Psi^{\#(\epsilon)} \mu_2$, if there exist two witness sub-distributions $\mu_L \in \distr(\mathcal{D}_1 \times \mathcal{D}_2)$ and $\mu_R \in \distr(\mathcal{D}_1 \times \mathcal{D}_2)$ s.t.:
\begin{enumerate}
	\item $\projl(\mu_L) = \mu_1$ and $\projr(\mu_R) = \mu_2$;
	\item $\supp(\mu_L) \subseteq \Psi$ and $\supp(\mu_R) \subseteq \Psi$; and
	\item $\Delta_{\epsilon}(\mu_L, \mu_R) \leq 0.0$.
\end{enumerate}
\end{defn}
%
%
\begin{defn}[$\Lambda$ equivalent]
Given two floating point values $\valv_1$ and $\valv_2$, if for some floating point value $\fvalv$ which is a multiple of $\Lambda$:
\[
	\fvalv - \frac{\Lambda}{2} \leq \valv_1 < \fvalv + \frac{\Lambda}{2}
	~~
	\land
	~~
	\fvalv - \frac{\Lambda}{2} \leq \valv_2 < \fvalv + \frac{\Lambda}{2},	
\]
then $\valv_1$ and $\valv_2$ are $\Lambda$ equivalent, i.e., 
$\valv_1 \lameq \valv_2 \lameq \fvalv$.
\end{defn}
%
%
\begin{defn}[tagged variable]
Let $\mathcal{X}\langle 1 \rangle$ and $\mathcal{X}\langle 2 \rangle$ be the sets of tagged variables, finite sets of variable names tagged with $\langle 1 \rangle$ or $\langle 2 \rangle$ respectively:
\[
	\mathcal{X}\langle 1 \rangle = \{\varx\langle 1 \rangle ~|~ x \in \mathcal{X}\}
	~~
	\text{and}
	~~
	\mathcal{X}\langle 2 \rangle = \{\varx\langle 2 \rangle ~|~ x \in \mathcal{X}\},
\]
where $\mathcal{X}$ is a finite set of variable names.
\end{defn}
%
\paragraph{Assertion.} We consider a set $\mathcal{A}$ of assertions (predicates) from first order logic by the following grammar:
\[
\begin{array}{llll}
%
%
\mbox{Logic Expr.} & \mathcal{E} & ::= & \mathcal{L}
	~|~ \mathcal{V}
 	~|~ \mathcal{E} + \mathcal{E}
%  \\
% & & &
 ~|~ \mathcal{E} - \mathcal{E}
 ~|~ \mathcal{E} \cdot \mathcal{E}
 ~|~ \ln(\mathcal{E}) ~|~ -\mathcal{E} ~|~ e^{\mathcal{E}}
	\\
%
\mbox{Assert.} & \mathcal{A} & ::= & 
\expr^{i} \langle 1 / 2 \rangle = \expr^i\langle 1 / 2 \rangle 
 ~|~ \expr^i\langle 1 / 2 \rangle < \expr^i\langle 1 / 2 \rangle) 
%  \\
% & & &
 ~|~ \expr^i\langle 1 / 2 \rangle \leq \expr^i\langle 1 / 2 \rangle
 ~|~ \expr^i\langle 1 / 2 \rangle \lameq \expr^i\langle 1 / 2 \rangle
	\\
 & & &
~|~  \mathcal{E} = \mathcal{E} ~|~ \cdots
~|~ \mathcal{E} =  \expr^{i} \langle 1 / 2 \rangle ~|~ \cdots
~|~ \expr^{i} \langle 1 / 2 \rangle =  \mathcal{E} ~|~ \cdots
	\\
 & & &
~|~  \top ~|~ \bot
	~|~ \mathcal{A} \land \mathcal{A} ~|~ \mathcal{A} \lor \mathcal{A} ~|~ \neg \mathcal{A}
	~|~ \mathcal{A} \imply \mathcal{A}
	~|~ \forall L \in \mathcal{D}. ~ \mathcal{A}
	~|~ \exists L \in \mathcal{D}. ~ \mathcal{A}
\end{array}
\]
%
We typically use capital Greek letters ($\Phi, \Psi, \cdots$) for predicates. 
%
$\expr\langle 1 / 2 \rangle$ denotes an expression where program variables are tagged with $\langle 1 \rangle$ or $\langle 2 \rangle$.
%
$\expr^i\langle 1 / 2 \rangle$ represents an expression where program variables are projected to the $i^{th}$ value from its triples, where $i \in \{1, 2, 3\}$. $\mathcal{D}$ is a specfic domain, it could be integers, $\real$, $\float$ or range of intergers, $\real$, $\float$, etc.
\\
The logic context are maps $\mathcal{L} \to \mathcal{V}$; usually written $\lmem$. The logic expression $\mathcal{E}$ is interpreted in a real computation way, such as:
%
$\sem{\mathcal{E}_1 + \mathcal{E}_2}_{\lmem} = \sem{\mathcal{E}_1}_{\lmem} + \sem{\mathcal{E}_2}_{\lmem}$, etc.
%
%
\paragraph{Assertion Interpretation.} Assertions are interpreted as relations between environments, i.e., set of paired environments. Let $\Phi$ be an assertion,
%
by the definition of $\mathcal{A}$, we have $\sem{\mathcal{A}}$ as:
\\
$\sem{\expr^i\langle 1 \rangle 
= \expr^i\langle 2 \rangle}_{\lmem} = 
\{(\trsmem_1, \trsmem_2) 
~|~ (\sem{\expr}_{\trsmem_{1}})^i 
= (\sem{\expr}_{\trsmem_2})^i \};
~ \cdots; 
%
~~~~
%
\sem{\mathcal{E}_1
= \mathcal{E}_2}_{\lmem} = 
\{(\trsmem_1, \trsmem_2) ~|~ \sem{\mathcal{E}_1}_{\lmem} 
< \sem{\mathcal{E}_2}_{\lmem} \};
~\cdots;
%
$
\\
$
%
\sem{\expr^i\langle 1 \rangle 
< \mathcal{E}}_{\lmem} = 
\{(\trsmem_1, \trsmem_2) ~|~ (\sem{\expr}_{\trsmem_{1}})^i 
< \sem{\mathcal{E}}_{\lmem} \};
~\cdots;
%
~~~~~~~~~~~~~~
\sem{\mathcal{E} 
\leq \expr^i\langle 2 \rangle}_{\lmem} = 
\{(\trsmem_1, \trsmem_2) ~|~ \sem{\mathcal{E}}_{\lmem}
\leq (\sem{\expr}_{\trsmem_2})^i \};
%
~\cdots;$
%
\\
$
\sem{\mathcal{A}_1 \land \mathcal{A}_2}_{\lmem} = \big\{(\trsmem_1, \trsmem_2)
~|~ (\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}_1}_{\lmem} \land 
	(\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}_2}_{\lmem} \big\};
~~~~~~~
\sem{\top}_{\lmem} = \{(\trsmem_1, \trsmem_2)\};
~~~~~~~~~~
\sem{\bot}_{\lmem}  = \{\};
$
%
\\
$\sem{\mathcal{A}_1 \lor \mathcal{A}_2}_{\lmem} = \big\{(\trsmem_1, \trsmem_2)
~|~ (\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}_1}_{\lmem} \lor 
	(\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}_2}_{\lmem} \big\};
	~~~~~~~
\sem{\neg \mathcal{A}}_{\lmem} = \big\{(\trsmem_1, \trsmem_2)
~|~ (\trsmem_1, \trsmem_2) \notin \sem{\mathcal{A}}_{\lmem} \big\};$
%
\\
$\sem{\mathcal{A}_1 \imply \mathcal{A}_2}_{\lmem} = \big\{(\trsmem_1, \trsmem_2)
~|~ (\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}_1}_{\lmem} \imply 
	(\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}_2}_{\lmem} \big\};$
%
\\
$\sem{\forall L \in \mathcal{D}. ~\mathcal{A}}_{\lmem} = \big\{(\trsmem_1, \trsmem_2)
~|~ \forall v \in \mathcal{D}. ~ (\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}}_{\lmem[L \to v]} \big\};$
%
\\
$\sem{\exists L \in \mathcal{D}. ~\mathcal{A}}_{\lmem} = \big\{(\trsmem_1, \trsmem_2)
~|~ \exists v \in \mathcal{D}. ~ (\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}}_{\lmem[L \to v]} \big\}.$
%
%
%
\paragraph{Judgment.}
The judgments are defined in following form:
\[
	\prog_1 \sim_{\epsilon} \prog_2: \Phi \Rightarrow \Psi.
\]
Here, $\prog_1$ and $\prog_2$ are programs and $\Phi$ and $\Psi$ are assertions on pairs of memories. Each assertions can refer to two copies $x\langle 1 \rangle, x\langle 2 \rangle$ of each program variable $x$, where these tagged variables refer to the value of x in the execution of $\prog_1$ and $\prog_2$ respectively.
%
\\
A judgment is valid, written $\vdash \prog_1 \sim_{\epsilon} \prog_2: \Phi_0 \Rightarrow \Phi$, 
if for any two environments $\trsmem_1$ and $\trsmem_2$ satisfying precondition $\Phi_0$, 
i.e., $(\trsmem_1, \trsmem_2) \in \sem{\Phi_0}$, there exists a lifting of $\Phi$ relating the output distributions: 
%
$(\sem{\prog_1}_{\trsmem_1})$ 
$\sem{\Phi}^{\#(\epsilon)}$ 
$(\sem{\prog_2}_{\trsmem_2})$.
%
\\
%
Fig. \ref{fig:aprhl} presents the main rules from apRHL+ \cite{barthe2016proving} excluding the while and condition rules which is not defined in out syntax, as well as the sampling rule, which we generalized in extended apRHL.
The rule in Fig. \ref{fig:aprhlplus} represents the lifting proved in soundness theorem.
%
\begin{figure}[ht]
\boxed{\vdash: prog \times prog \times \real \times Assert \times Assert}
{\small
\begin{mathpar}
\inferrule
{
	\empty
}
{
	\vdash
	\varx \samplel \uniform(0, 1] 	
	\sim_{\epsilon} 
	\vary \samplel \uniform(0, 1]
	:
	\top
	\Rightarrow
	\varx^1 \langle 1 \rangle 
	= 
	e^{\epsilon} \vary^1 \langle 2 \rangle 	
}
~\textbf{Unif}
\and
%
\inferrule
{
\empty
}
{
	\vdash 
	\varx_1 \samplel \edistr
	\sim_{0} 
	\varx_2 \samplel \edistr
	: \top \Rightarrow 
	(\varx_2^1\langle 2 \rangle) 
	= (\varx_1^1\langle 1 \rangle )
	\land (\varx_2^2\langle 2 \rangle) = (\varx_1^2\langle 1 \rangle)
	\land (\varx_2^3\langle 2 \rangle) = (\varx_1^3\langle 1 \rangle)
}~\textbf{Null}
\and
\inferrule
{
\forall \valv. \text{ a multiple of } \Lambda
}
{
	\vdash 
	\varx_1 = \round{\vary_1}_{\Lambda}	
	\sim_{0} 
	\varx_2 = \round{\vary_2}_{\Lambda}
	: \vary_1^1 \langle 1 \rangle \lameq \valv
	\imply
	\vary_2^1 \langle 2 \rangle \lameq \valv
	\Rightarrow 
	(\varx^1_1 \langle 1 \rangle = \valv) 
	\imply (\varx^1_2 \langle 2 \rangle = \valv)
}~\textbf{Round}
\end{mathpar}
}
\caption{Rules Extended from apRHL+}
\label{fig:aprhlplus}
\end{figure}
%
\begin{figure}[ht]
\begin{mathpar}
\inferrule
{
\empty
}
{
	\vdash 
	\varx_1 = \expr_1  
	\sim_{0} 
	\varx_2 = \expr_2  
	: \Phi[\expr_1/\varx_1\langle 1 \rangle]
	[\expr_2/\varx_2\langle 2 \rangle]  \Rightarrow \Phi
}~\textbf{Assn}
~~~
\inferrule
{
\vdash
\prog_1 \sim_{\epsilon} \prog_2 : \Phi_1 \Rightarrow \Phi'_1
\\
\vdash
\prog'_1 \sim_{\epsilon'} \prog'_2 : \Phi'_1 \Rightarrow \Phi_2
}
{
	\vdash 
	\prog_1; \prog'_1  
	\sim_{\epsilon + \epsilon'} 
	\prog_2; \prog'_2
	: \Phi_1  \Rightarrow  \Phi_2
}~\textbf{Seq}
\and
\inferrule
{
\vdash
\prog_1 \sim_{\epsilon} \prog_2 : \Phi'_1 \Rightarrow \Phi'_2
\and
\vDash
\Phi_1 \Rightarrow \Phi'_1
\and 
\vDash
\Phi'_2 \Rightarrow \Phi_2
\and 
\epsilon \leq \epsilon'
}
{
\vdash
\prog_1 \sim_{\epsilon'} \prog_2 : 
\Phi_1 \Rightarrow \Phi_2
}~\textbf{Conseq}
\and
\extend{
\inferrule
{
\vDash
\Phi \to \bexpr_1 \langle 1 \rangle = \bexpr_2 \langle 2 \rangle
\and
\vdash
\prog_t \sim_{\epsilon} \prog_t' :
\Phi \land \bexpr_1 \langle 1 \rangle  \Rightarrow \Psi
\and
\vdash
\prog_f \sim_{\epsilon} \prog_f' :
\Phi \land \neg \bexpr_1 \langle 1 \rangle  \Rightarrow \Psi}
{
\vdash
\eif \bexpr_1 \ethen \prog_t \eelse \prog_f 
\sim_{\epsilon} \eif \bexpr_2 \ethen \prog_t' \eelse \prog_f' : 
\Phi \Rightarrow \Psi
}~\textbf{Cond}
}
%
\and
%
\extend{
\inferrule
{
\vDash \Phi \land \expr_{\gamma} \langle 1 \rangle \leq 0
\to \neg \expr_1 \langle 1 \rangle
\and
\vDash
\Phi \to \expr \langle 1 \rangle = \expr \langle 2 \rangle
\\
\forall K \in \mathbb{N}, 
\vdash \prog_1 \sim_{\epsilon}  \prog_2 :
\Phi \land \expr_1 \langle 1 \rangle 
\land \expr_{\gamma} \langle 1 \rangle  = K 
\Rightarrow \Phi \land \expr_{\gamma} \langle 1 \rangle  < K
}
{
\vdash
\ewhile \bexpr_1 \edo \prog_1 \sim_{N\epsilon} 
\ewhile \bexpr_2 \edo \prog_2 : 
\Phi \land \expr\langle 1 \rangle \leq N 
\Rightarrow \Phi \land \neg \expr_1 \langle 1 \rangle
}~\textbf{While}
}
\end{mathpar}
\caption{Proving Rules from apRHL}
\label{fig:aprhl}
\end{figure}
%
%
\begin{lem}[Discrete Support of Distribution]
 $\forall \prog, \trsmem, \edistr$,  s.t. $\edistr \in \distr(Env)$ and $\sem{\prog}_{\trsmem} = \edistr$. Then $\supp{(\edistr)}$ is discrete.
\end{lem}
%
%
\begin{proof}
By induction on $\prog$, we have following cases:
\begin{itemize}
	\caseL{$\varx \samplel \edistr$}
	Given the porgam as $\varx \samplel \edistr$ and $\trsmem$, 
	we have $\edistr$ in this case as:
	\\
	%
	$\elet \fval_{(\rval_{l}, \rval_{u})} = \sem{\edistr}_{\trsmem}
	\ein 
	\unit{\trsmem[\varx \mapsto \fval_{(\rval_{l}, \rval_{u})}]}
	$
	%
	\\
	%
	Since $\trsmem$ is given and will not change, then it is equivalent to show the support of following distribution is discrete:
	\\ 
	$\elet \fval_{(\rval_{l}, \rval_{u})} = \sem{\edistr}_{\trsmem}
	\ein 
	\unit{\fval_{(\rval_{l}, \rval_{u})}}$.
	%
	\\
	By the Monad Law, it is equivalent to show support of $\sem{\edistr}_{\trsmem}$ is discrete given $\trsmem$.
	\\
	By induction on $\edistr$ we have following two subcases:
	%
	\subcaseL{$\uniform(0,1]$}
	%
	We have 
	$\sem{\uniform(0,1]}_{\trsmem} \in 
	\big\{
	(\fval_{(\rval_{l}, \rval_{u})}) ~|~
	\fval \leftarrow \muniform(0, 1]
	\land \rval_{l} = \rval_{u} = \fval
	\big\}$.
	\\
	Since $\supp(\muniform(0, 1]) \in (0, 1]^{\float}$ and $\rval_{l} = \rval_{u} = \fval$, we have:
	\\ 
	$\left \vert\big\{
		(\fval_{(\rval_{l}, \rval_{u})}) ~|~
		\fval \leftarrow \muniform(0, 1]
		\land \rval_{l} = \rval_{u} = \fval
		\big\} \right \vert
	= \left \vert (0, 1]^{\float} \right \vert$,
	 %
	i.e., $\left \vert \supp(\sem{\uniform(0,1]}_{\trsmem}) \right\vert = \left \vert (0, 1]^{\float} \right \vert$.
	\\
	Then $\supp(\sem{\uniform(0,1]}_{\trsmem})$ is obviously discrete.
	%
	\subcaseL{$\uniform\{-1, 1\}$}
	%
	We have $\sem{\uniform\{-1, 1\}}_{\trsmem} \in  
	\big\{
	(-1_{(-1, -1)}), (1_{(1, 1)}) ~|~
	each ~ w.p. ~ 0.5 
	\big\}$ by the interpretation of distributions.
	\\
	Since $\left \vert \supp(\sem{\uniform(0,1]}_{\trsmem}) \right\vert = \left \vert \big\{
	(-1_{(-1, -1)}), (1_{(1, 1)}) ~|~
	each ~ w.p. ~ 0.5 
	\big\} \right \vert = 2$.
	%
	\\
	%
	Then, it is obviously that $\supp(\sem{\uniform(0,1]}_{\trsmem})$ is discrete.
	%
	%
	\caseL{$\varx = \expr$}
	Given the porgam as $\varx = \expr$ and $\trsmem$, 
	we have $\edistr$ in this case as:
	\\
	$\unit{\trsmem[\varx \mapsto \sem{\expr}_{\trsmem}]}$.
	\\
	Given $\trsmem$ will not change, it is equivalent to show 
	$\supp(\unit{\sem{\expr}_{\trsmem}})$ is discrete.
	%
	\\
	%
	By interpretation of $\expr$, we have: 
	$\sem{\expr}_{\trsmem} \in  
	\big\{\fval_{(\rval_{l}, \rval_{u})} ~|~
	\trsmem,  
	\expr \trsto (\fvalv_{(\rval_{l}, \rval_{u})})\big\}$.
	\\
	%
	Given $\expr$ and $\trsmem$, 
	there is one and only one $\fvalv$ deterministically evaluated in floating point computation, and one and only one $(\rval_{l}, \rval_{u})$ deterministically computed from $\expr$, $\trsmem$ and $\fvalv$, we know:
	\\
	$\left \vert \supp(\unit{\sem{\expr}_{\trsmem}}) \right \vert  
	= 
	\left \vert \big\{\fval_{(\rval_{l}, \rval_{u})} ~|~
		\trsmem,  
		\expr \trsto (\fvalv_{(\rval_{l}, \rval_{u})})\big\} \right \vert  = 1$.
	%
	\\
		Then, it is obviously that $\supp(\unit{\trsmem[\varx \mapsto \sem{\expr}_{\trsmem}]})$ is discrete.
	%
	\caseL{$\prog_1; \prog_2$}
	Given the porgam as $\prog_1; \prog_2$ and $\trsmem$, 
	we have $\edistr$ in this case as:
	\\
	$\elet  \trsmem_1 = 
	 	\sem{\prog_1}_{\trsmem} \ein
	 	\sem{\prog_2}_{\trsmem_1}$ 
	 %
	 \\
	 By induction hypothesis, we have:
	 \\
	 $\supp(\sem{\prog_1}_{\trsmem})$ is discrete $~(1)$; and 
	 $\forall \trsmem_1 \in \supp(\sem{\prog_1}_{\trsmem})$, $\supp(\sem{\prog_2}_{\trsmem_1})$ are all discrete.
	 %
	 \\
	 Then we have: $\left \vert \supp(\edistr) \right \vert = \sum_{\trsmem_1 \in \supp(\sem{\prog_1}_{\trsmem})} \left \vert \supp(\sem{\prog_2}_{\trsmem_1}) \right \vert$ is also finite.
	 \\
	 We can then conclude that $\supp(\edistr)$ is discrete.
	 %
	 %
	 \caseL{
	 $\extend{\eif \bexpr \ethen \prog_t \eelse \prog_f}$}
	%
	Given the porgam as $\eif \bexpr \ethen \prog_t \eelse \prog_f$ 
	and $\trsmem$, 
	we have $\edistr$ be either $\sem{\prog_t}_{\trsmem}$ or $\sem{\prog_f}_{\trsmem}$.
	 %
	 \\
	 By induction hypothesis, we have:
	 \\
	 both $\supp(\sem{\prog_t}_{\trsmem})$ is discrete $~(1)$; and $\supp(\sem{\prog_f}_{\trsmem})$ is discrete $~(2)$.
	 \\
	%
	Then this case is proved.
	%
	\caseL{
	$\extend{\ewhile \bexpr \edo \prog}$
	}
	%
	\[	
	\left\{
	\begin{array}{ll}
	\elet \trsmem' = \sem{\prog}_{\trsmem} \ein 
	\sem{\ewhile \bexpr \edo \prog}_{\trsmem'}
	  & : \sem{\bexpr}_{\trsmem} = \etrue \\
	\unit \trsmem & : \sem{\bexpr}_{\trsmem} = \efalse \\
	\end{array}
	\right .
	\]
	Given the porgam as $\ewhile \bexpr \edo \prog$ and $\trsmem$, 
	we have $\edistr$ as :
	\\
	either $\unit \trsmem$ or
	$\elet \trsmem' = \sem{\prog}_{\trsmem} \ein 
	\sem{\ewhile \bexpr \edo \prog}_{\trsmem'}$ 
	 %
	 \\
	 It is obvously that $\supp( \unit \trsmem) = \{\trsmem\}$ is discrete.
	 \\
	 By induction hypothesis, we have:
	 \\
	 $\supp(\sem{\prog}_{\trsmem})$ is discrete $~(1)$; and 
	 $\forall \trsmem' \in \supp(\sem{\prog}_{\trsmem})$, $\supp(\sem{\ewhile \bexpr \edo \prog}_{\trsmem'})$ are all discrete.
	 %
	 \\
	 Then we have: $\left \vert \supp(\edistr) \right \vert = \sum_{\trsmem' \in \supp(\sem{\prog}_{\trsmem})} \left \vert \supp(\sem{\ewhile \bexpr \edo \prog}_{\trsmem'}) \right \vert$ is also finite.
	 \\
	 We can then conclude that $\supp(\edistr)$ is discrete.
	 %
	 %
\end{itemize}
\end{proof}
%
%
%
\clearpage
\begin{thm}[Soundness]
 $\forall \prog_1$, $\prog_2$,  $ \vdash \prog_1	
\sim_{\epsilon} 
\prog_2 :
\Phi_0 \Rightarrow \Phi $,    $\forall \trsmem_1$, $\trsmem_2$ 
s.t $\Phi_0$: 
$\trsmem_1 ~ \sem{\Phi_0} ~ \trsmem_2$,
then
$$ 
(\sem{\prog_1}_{\trsmem_1})  
\sem{\Phi}^{\#(\epsilon)} 
(\sem{\prog_2}_{\trsmem_2}) 
$$.
\end{thm}
%
%
%
\begin{proof}[Proof of Core Rules]
By induction on the judgment $\vdash \prog_1	
\sim_{\epsilon}
\prog_2 :
\Phi_0 \Rightarrow \Phi $, we have following cases:
\begin{itemize}
\caseL{{\small\[
\inferrule
{
	\empty
}
{
	\vdash
	\varx \samplel \uniform(0, 1] 	
	\sim_{\epsilon} 
	\vary \samplel \uniform(0, 1]
	:
	\top
	\Rightarrow
	\varx^1 \langle 1 \rangle 
	= 
	e^{\epsilon} \vary^1 \langle 2 \rangle 	
}~\textbf{unif}
\]}}
	In this case, 
	assume $m_1, m_2$, $\rvalL, \rvalR \in (0,1]^{\real}$, s.t.,
	$(m_1, m_2) \in \sem{\Phi_0}$, where the precondition
	$
	\Phi_0 \triangleq
	\top
	$
	%
	is interpreted as:
	%
	\[
	\sem{\Phi_0} =
	\left \{
	(m_1, m_2)
	\right \}
	\]
	%
	%
	The post-condition $\Phi \triangleq 
			\Rightarrow
	\varx^1 \langle 1 \rangle 
	= 
	e^{\epsilon} \vary^1 \langle 2 \rangle 	
	$ is interpreted as:
	%
	\[
	\sem{\Phi} =
	\left \{
	(m_1, m_2)
	~ \left \vert ~
	\sem{\varx}_{\trsmem_1}^1 =
	e^{\epsilon} \sem{\vary}_{\trsmem_2}^1
		\land \sem{\vary}_{\trsmem_2}^1 \leq 1)
	\right.
	\right \}
	\]
	%
	Let $(\fvalv_{(\rvalv_{l}, \rvalv_{u})}) = \sem{x}_{m_1}$ and 
	$(\fvalw_{(\rvalw_{l}, \rvalw_{u})}) = \sem{y}_{m_2}$, we can rewrite the interpretation of $\sem{\Phi}$ as:
	%
\[
	\sem{\Phi} =
	\left \{
	(m_1, m_2)
	~ \left \vert ~
	\begin{array}{l}
	(\fvalv_{(\rvalv_{l}, \rvalv_{u})}) = \sem{x}_{m_1}
	\land 
	(\fvalw_{(\rvalw_{l}, \rvalw_{u})}) = \sem{y}_{m_2}
	\\
	\land
	\fvalv = e^{\epsilon}  \fvalw
		\land \fvalw \leq 1)
	\end{array}
	\right.
	\right \}
\]
	%
	By the semantics of sampling, we have:\\
	%
	$\sem{\varx \samplel \uniform(0, 1]}_{\trsmem_1} =
	\elet (\fvalv_{(\rvalv_{l}, \rvalv_{u})}) 
	= \sem{\uniform(0, 1]}_{\trsmem_1} 
	\ein 
	\unit{\trsmem_1[\varx \mapsto (\fvalv_{(\rvalv_{l}, \rvalv_{u})})]}
	$
	%
	\\
	%
	$\sem{\vary \samplel \uniform(0, 1]}_{\trsmem_2} = 
	\elet (\fvalw_{(\rvalw_{l}, \rvalw_{u})})
	= \sem{\uniform(0, 1]}_{\trsmem_2} 
	\ein 
	\unit{\trsmem_2[\vary \mapsto (\fvalw_{(\rvalw_{l}, \rvalw_{u})})]}
	$. \\
	%
	Then we need to prove:
	\[\mu_1(\trsmem_1) \sem{\Phi}^{\#(\epsilon)} \mu_2(\trsmem_2),\]
	where 
	$\mu_1(\trsmem) = 
	\elet (\fvalv_{(\rvalv_{l}, \rvalv_{u})}) 
	= \sem{\uniform(0, 1]}_{\trsmem} 
	\ein 
	\unit{\trsmem[\varx \mapsto (\fvalv_{(\rvalv_{l}, \rvalv_{u})})]}$ and
	%
	\\
	%
	$\mu_2(\trsmem) = 
	\elet (\fvalw_{(\rvalw_{l}, \rvalw_{u})})
	= \sem{\uniform(0, 1]}_{\trsmem} 
	\ein 
	\unit{\trsmem[\vary \mapsto (\fvalw_{(\rvalw_{l}, \rvalw_{u})})]}$.
	%
	\\
	%
	Now the following subproof is to show the subgoal:
	%
	\\
	\textbf{Subgoal:} For any pair of environments $(\trsmem_1, \trsmem_2)$, if we can show ${\muniform(0,1]} ~ R^{\#(\epsilon)} ~ {\muniform(0,1]}$, then $\mu_1(\trsmem_1) \sem{\Phi}^{\#(\epsilon)} \mu_2(\trsmem_2)$,
	%
	where
	\[
		R = 
		\left \{(\fval_1, \fval_2) \in \float \times \float 
		~\vert~
		\fval_1  = e^{\epsilon}  \fval_2 
		\land \fval_2 \leq 1
		\right \}.
	\]	% \[
	%
	\begin{subproof}
	%
	It is equivalent to show following 3 items for any environment $\trsmem_1, \trsmem_2$:
	\\
	%
	(i) For any $\muniform(0,1]\in \distr(\float)$, there is one and only one $\edistr_1(\trsmem_1) \in \distr(Env)$.
	%
	\\
	(ii) For any $\muniform(0,1] \in \distr(\float)$, there is one and only one $\edistr_2(\trsmem_2) \in \distr(Env)$.
	\\
	%
	(iii) For any pair of float value $(\fvalv_1, \fvalv_2) \in R$ where 
	$\fvalv_1 \in \supp(\muniform(0,1])$, 
	$\fvalv_2 \in \supp(\muniform(0,1])$,
	there is one and only one pair of environments 
	$(\trsmem_1[ \varx_1 \to \fval_{1(\rval_{1l}, \rval_{1u})}], \trsmem_2[\varx_2 \to \fval_{2(\rval_{2l}, \rval_{2u})}]) \in \sem{\Phi}$
	where $\rval_{1l}, \rval_{1u}, \rval_{2l}, \rval_{2u} \in \real$.
	%
	\\ 
	%
	\textbf{Proof of (i):} 
	Given $\muniform(0,1]$, for any $\fval_1 \in \supp(\muniform(0,1])$, 
	we can always find one and only one $\fval_{1(\rval_{1l}, \rval_{1u})}$ where $\rval_{1l} = \fval_1 = \rval_{1u}$.
	%
	\\
	Then given environment $m_1$,
	we can construct one and only one $\sem{\uniform(0, 1)}_{\trsmem_1} \in \distr(\float_{\real \times \real})$
	by assigning the pdf on $\fval_{1(\rval_{1l}, \rval_{1u})}$ the same as $\pdf_{\muniform(0,1]}(\fval_1)$. 
	\\
	%
	Then we have the pdf of $\sem{\uniform(0, 1)}_{\trsmem_1}$  
	is defined as $\pdf_{\sem{\uniform(0, 1)}_{\trsmem_1}}$:
	%
	\[
	\pdf_{\sem{\uniform(0, 1)}_{\trsmem_1}}(\fval_{1(\rval_{1l}, \rval_{1u})}) = 
		\begin{cases}
		1 & \fval_1 \in (0,1]^{\mathbb{F}}
		\land  \fval_1 = \rval_{1l} = \rval_{1u}
		\\
		0       & o.w.
		\end{cases},
	\]
	Then by the Monad Law, we have the distribution:
	$\elet \fval_{1(\rval_{1l}, \rval_{1u})} = \sem{\uniform(0, 1)}_{\trsmem_1} 
	\ein \unit{\fval_{1(\rval_{1l}, \rval_{1u})}}$.
	% %
	\\
	%
	Since for any $\fval_{1(\rval_{1l}, \rval_{1u})} \in \sem{\uniform(0, 1)}_{\trsmem_1}$, 
	we can always construct one and only one environment $\trsmem_1[\varx_1 \mapsto (\fval_{1(\rval_{1l}, \rval_{1u})})]$.
	%
	\\
	Then we compose the  
	$\trsmem_1[\varx_1 \mapsto (\fval_{1(\rval_{1l}, \rval_{1u})})]$
	with $\elet \fval_{1(\rval_{1l}, \rval_{1u})} = \sem{\uniform(0, 1)}_{\trsmem_1} 
	\ein \unit{\fval_{1(\rval_{1l}, \rval_{1u})}}$ and get:
	%
	%
	$\mu_1(\trsmem_1) \in \distr(\float_{\real \times \real})$ as 
	$\elet \fval_{1(\rval_{1l}, \rval_{1u})} = \sem{\uniform(0, 1)}_{\trsmem_1} 
	\ein \unit{\trsmem_1[\varx_1 \mapsto (\fval_{1(\rval_{1l}, \rval_{1u})})]}$.
	\\
	%
	In this way, (i) are proved.
	\\
	%
	\textbf{Proof of (ii):} 
	We can also prove (ii) by repeating every steps above except substituting $\trsmem_1, \fvalv_1, \rvalv_{1l}$ and $\rvalv_{1u}$ with $\trsmem_2, \fvalv_2, \rvalv_{2l}$ and $\rvalv_{2u}$.
	%
	\\
	\textbf{Proof of (iii):} 
	Given any pair of float value $(\fvalv_1, \fvalv_2) \in R$ where 
	$\fvalv_1 \in \supp(\muniform(0,1])$, 
	$\fvalv_2 \in \supp(\muniform(0,1])$, we have by definition of $R$:
	%
	$\fval_1  = e^{\epsilon}  \fval_2 
		\land \fval_2 \leq 1
	 ~ (3)$
	\\
	%
	By (i) and (ii), we can also construct one and only one pair of environments $\trsmem_1', \trsmem_2'$ as:
	\\
	$\trsmem_1' = \trsmem_1[\varx_1 \to \fval_{1(\rval_{1l}, \rval_{1u})}] ~ (4)$ and
	$\trsmem_2' = \trsmem_2[\varx_2 \to \fval_{2(\rval_{2l}, \rval_{2u})}] ~ (5)$,
	\\
	where $\rval_{1l} = \fval_1 = \rval_{1u}$ and $\rval_{2l} = \fval_2 = \rval_{2u}$.
	%
	\\
	In order to show $(\trsmem_1', \trsmem_2') \in \sem{\Phi}$, we need to prove:
	\\
	(a)	$(\fval_{1(\rval_{1l}, \rval_{1u})}) = \sem{x_1}_{m_1}$.
	This is proved by (5).
	\\
	(b) $(\fval_{2(\rval_{2l}, \rval_{2u})}) = \sem{x_2}_{m_2}$.
	This is proved by (6).
	\\
	(c) $\fval_1  = e^{\epsilon}  \fval_2 
		\land \fval_2 \leq 1$.
	This is proved by (3).
	\\
	Then we have (iii) proved. 
	\end{subproof}
	%
	Since we have $\muniform(0,1] ~ R^{\#(\epsilon)} ~ \muniform(0,1]$ proved in the Theorem \ref{thm:unif_coupling},
	%
	where 
	\[
		R = 
		\left \{(\fval_1, \fval_2) \in \float \times \float 
		~|~
		\forall \rvalL, \rvalR \in [0,1]^{\real}. ~
		\rvalL \leq \fval_1 \leq \rvalR
		\imply
		(e^{\epsilon} \rvalL \leq \fval_2 \leq 	e^{\epsilon} \rvalR
		\land \fval_2 \leq 1)
		\right \}.
	\]	%
	Then we have $\mu_1(\trsmem_1) \sem{\Phi}^{\#(\epsilon)} \mu_2(\trsmem_2)$ proved according to \textbf{Subgoal}.
	%
	% \caseL{[\textsc{unif-}] }
	% %
	% The same as case [\textsc{unif}].
	% 	Since we have $\muniform(0,1] ~ R^{\#(\epsilon)} ~ \muniform(0,1]$ proved in the Theorem \ref{thm:unif-_coupling},
	% %
	% where 
	% \[
	% 	R = 
	% 	\left \{(\fval_1, \fval_2) \in \float \times \float 
	% 	~|~
	% 	\forall \rvalL, \rvalR \in [0,1]^{\real}. ~
	% 	\rvalL \leq \fval_1 \leq \rvalR
	% 	\imply
	% 	e^{-\epsilon} \rvalL \leq \fval_2 \leq 	e^{-\epsilon} \rvalR
	% 	\right \}.
	% \]
	% %
	% Then we have $\mu_1(\trsmem_1) \sem{\Phi}^{\#(\epsilon)} \mu_2(\trsmem_2)$ proved.
	%
	\caseL{[\textsc{Null}] }
	%
	This case is obviously proved by picking the witnesses be the joint distribution of two $\muniform(0, 1)$s.
	%
	The support of witnesses are on the relation of equality.
	%
	\end{itemize}
\end{proof}
%
\newpage
\begin{thm}
\label{thm:unif_coupling}
%
$${\muniform(0,1]} ~ R^{\#(\epsilon)} ~ {\muniform(0,1]},$$
%
where
	$	R = 
		\left \{(\varx, \vary) \in {\float} \times {\float} 
		~|~
		\fval_1  = e^{\epsilon}  \fval_2 
		\land \fval_2 \leq 1
		\right \}
		$.
	%
\end{thm}
%
\begin{proof}[Proof of Theorem \ref{thm:unif_coupling}]
%
Let $\edistr_1 = \muniform(0, 1]$ and $\edistr_2 = \muniform(0, 1]$, it is equivalent to show 
${\edistr_1} ~ R^{\#(\epsilon)} ~ \edistr_2$.
%
%
%
\\
%
Let $\mu_L, \mu_R \in \distr\left({\float} \times {\float}\right)$ 
be the two witness distribution s.t.
their $\pdf.$ are defined as:
{\small\[
	\pdf_{\mu_L}(x, y) = 
	\begin{cases}
	\frac{1}{\left \vert (0, 1]^{\float} \right \vert} 
	& x = y \cdot e^{-\epsilon} \land x \in (0, e^{-\epsilon})\\
	\frac{1}{\left \vert (0, 1]^{\float} \right \vert} 	
	& x \in [e^{-\epsilon}, 1] \land y = 1\\
	0       
	& o.w.
	\end{cases};
~~~
	\pdf_{\mu_R}(x, y) = 
	\begin{cases}
	\frac{1}{\left \vert (0, 1]^{\float} \right \vert}	
	& x = y \cdot e^{-\epsilon} \land y \in (0, 1)\\
	\frac{1}{\left \vert [e^{-\epsilon}, 1]^{\float} \right \vert} \cdot \frac{1}{\left \vert (0, 1]^{\float} \right \vert}
	& x \in [e^{-\epsilon}, 1] \land y = 1\\
	0       & o.w.
	\end{cases}.
\]
}
It is enough to show that $\edistr_L(x, y)$ and $\edistr_R(x, y)$ are satisfying following three requirements:
\begin{itemize}
	\item $\supp(\mu_L) \subseteq R \land \supp(\mu_R) \subseteq R$
%
%
%
	\begin{itemize}
		\item $\supp(\mu_L) \subseteq R$ 
		%
		\\
		% 
		By definition of the $\pdf$ of $\mu_L$, 
		$\supp(\mu_L) = \{(x, y) ~\vert~ \pdf_{\mu_L}(x, y) > 0\}$,
		we have: 
		\\
		$\supp(\mu_L) = \{(x, y) ~\vert~ 
		x = y \cdot e^{-\epsilon} \land x \in (0, e^{-\epsilon}) 
		\land x \in [e^{-\epsilon}, 1] \land y = 1
		\}$.
		\\  
		Then we know $\supp(\mu_L) \subseteq R$.
		%
		%
		we can then derive $\supp(\mu_L) \subseteq R$.
		%
		\item $\supp(\mu_R) \subseteq R$
		%
		\\
		%
		By definition of the $\pdf$ of $\mu_R$, 
		$\supp(\mu_R) = \{(x, y) ~\vert~ \pdf_{\mu_R}(x, y) > 0\}$,
		we have: 
		\\
		$\supp(\mu_R) = \{(x, y) ~\vert~ 
		x = y \cdot e^{-\epsilon} \land y \in (0, 1)
		\land
		x \in [e^{-\epsilon}, 1] \land y = 1 \}$
		\\  
		Then we know $\supp(\mu_R) \subseteq R'$. 
		%
		\\
		%
		Since $R' \subseteq R$, 
		%
		we can then derive $\supp(\mu_R) \subseteq R$.
		%
	\end{itemize}		
%
	\item $\projl(\mu_L) = \mu_1 \land \projr(\mu_R) = \mu_2$
	%
	\begin{itemize}
		\item $\projl(\mu_L) = \mu_1$ 
		\\
		% Equivalent to show $\pdf_{\projl(\mu_L)}  = \pdf_{\mu_1}$.
%
		By definition of the $\projl$ and $\pdf$ of $\mu_L$, we have $\forall x  \in \float$:
		\[
			\pdf_{\projl(\mu_L)}(x) = 
			\begin{cases}
			\sum_{y}\frac{1}{\left \vert (0, 1]^{\float} \right \vert} 
			& x = y \cdot e^{-\epsilon}  \land x \in (0, e^{-\epsilon})\\
			\sum_{y} \frac{1}{\left \vert (0, 1]^{\float} \right \vert} 
			& x \in [e^{-\epsilon}, 1] \land y = 1\\
			0       & o.w.
			\end{cases} 
			= 
			\begin{cases}
			\frac{1}{\left \vert (0, 1]^{\float} \right \vert}
			&  x \in (0, e^{-\epsilon})\\
			\frac{1}{\left \vert (0, 1]^{\float} \right \vert}
			& x \in [e^{-\epsilon}, 1] \\
			0       & o.w.
			\end{cases}
			=
			\pdf_{\mu_1}(x)
		\]

		\item $\projr(\mu_R) = \mu_2$ 
		%
		\\
		Equivalent to show$\pdf_{\projr(\mu_R)}  = \pdf_{\mu_2}$.
		\\
		%
		By definition of the $\projr$ and $\pdf$ of $\mu_R$, we have $\forall y \in \float$:
		%
		\[
			\pdf_{\projr(\mu_R)}(y) = 
			\begin{cases}
			\sum_{x} 
			\frac{1}{\left \vert (0, 1]^{\float} \right \vert} 
			& x = y \cdot e^{-\epsilon} \land y \in (0, 1)\\
			\sum_{x} 
			\frac{1}{\left \vert [e^{-\epsilon}, 1]^{\float} \right \vert} 
			\cdot
			\frac{1}{\left \vert (0, 1]^{\float} \right \vert} 
			& x \in [e^{-\epsilon}, 1] \land y = 1\\
			0       & o.w.
			\end{cases} 
			= 
			\begin{cases}
			\frac{1}{\left \vert (0, 1]^{\float} \right \vert}
			& y \in (0, 1)\\
			\frac{1}{\left \vert (0, 1]^{\float} \right \vert}  
			& y = 1\\
			0       & o.w.
			\end{cases}
			=
			\pdf_{\mu_2}(y)
		\]
	\end{itemize}	
%
	\item $\Delta_{\epsilon}(\mu_L, \mu_R) \leq 0$
%
\\
	By definition of $\epsilon-$DP divergence, we have:
	 \[
	 \begin{array}{ll}
	 \Delta_{\epsilon}(\mu_L, \mu_R) 
	 & = \underset{S}{\psup}
	 \Big(
	 \pr{(x,y) \samplel \mu_L}{(x,y) \in S} - e^{\epsilon} \pr{(x,y) \samplel \mu_R}{(x,y) \in S}
	 \Big) \\
	 & =\underset{S}{\psup}
	 \Big(
	 \sum_{(x,y) \in S} \pdf_{\mu_L}(x, y) - e^{\epsilon} \sum_{(x,y) \in S} \pdf_{\mu_R}(x, y)
	 \Big)	 
	 \end{array}
	 \]
	 \begin{itemize}
	 	\item[{\bf case}]
	 	%
	 	$S \subseteq \{(x, y) ~|~ 
	 	x = y \cdot e^{-\epsilon}  \land x \in (0, e^{-\epsilon}) \}$:
	 	%
		\[
		 \begin{array}{ll}
		 \Delta_{\epsilon}(\mu_L, \mu_R) 
		 & = 
		 \sum_{(x,y) \in S} \frac{1}{\left \vert (0, 1]^{\float} \right \vert})
		 - e^{\epsilon} \sum_{(x,y) \in S} \frac{1}{\left \vert (0, 1]^{\float} \right \vert}) \\ 
		 & = 
		 (1 - e^{\epsilon})\sum_{(x,y) \in S} \frac{1}{\left \vert (0, 1]^{\float} \right \vert} 
		 \leq 0 
		 \end{array}
		 \]
		 %
	 	\item[{\bf case}] $S \subseteq \{(x, y) 
	 	~|~ x \in [e^{-\epsilon}, 1] \land y = 1 \}$:
	 	%
		 \[
		 \begin{array}{ll}
		 \Delta_{\epsilon}(\mu_L, \mu_R) 
		 & = 
		 \sum_{(x,y) \in S} 
			\frac{1}{\left \vert (0, 1]^{\float} \right \vert} 
			 - 
		 e^{\epsilon} \sum_{(x,y) \in S} \frac{1}{\left \vert [e^{-\epsilon}, 1]^{\float} \right \vert} 
			\cdot
			\frac{1}{\left \vert (0, 1]^{\float} \right \vert} \\
		 %
		 &  = \frac{1}{\left \vert (0, 1]^{\float} \right \vert}
		 (1 - e^{\epsilon}) \leq 0
		 \end{array}
		 \]
		 %
	 	\item[{\bf case}] o.w.:
	 	%
		 \[
		 \Delta_{\epsilon}(\mu_L, \mu_R) = 0 - 0 =  0 
		 \]	 	

	 \end{itemize}

\end{itemize}
\end{proof}
%
%
\begin{corr}
{\small
\begin{mathpar}
\inferrule
{
	\empty
}
{
	\vdash
	\varx \samplel \uniform(0, 1] 	
	\sim_{\epsilon} 
	\vary \samplel \uniform(0, 1]
	:
	\top
	\Rightarrow
	\forall \rvalL, \rvalR \in [0,1]^{\real}. ~
	\rvalL \leq \varx^1 \langle 1 \rangle \leq \rvalR 
	\imply
	(e^{\epsilon} \rvalL \leq \vary^1 \langle 2 \rangle \leq e^{\epsilon}\rvalR \land \vary^1 \langle 2 \rangle \leq 1)	
}
~\textbf{Unif+}
\and
\inferrule
{
	\empty
}
{
	\vdash
	\varx \samplel \uniform(0, 1] 	
	\sim_{\epsilon} 
	\vary \samplel \uniform(0, 1]
	:
	\top
	\Rightarrow
	\forall \rvalL, \rvalR \in [0,1]^{\real}.
	(\rvalL \leq \varx^1 \langle 1 \rangle \leq \rvalR 
	 		\imply
	 		e^{-\epsilon} \rvalL \leq \vary^1 \langle 2 \rangle \leq e^{-\epsilon}\rvalR) 	
}
~\textbf{Unif-}
\end{mathpar}
}
\end{corr}
%
%
\begin{proof}
Soundness of the two corollary rules:
\begin{itemize}
\caseL{{\small\[
\inferrule
{
	\empty
}
{
	\vdash
	\varx \samplel \uniform(0, 1] 	
	\sim_{\epsilon} 
	\vary \samplel \uniform(0, 1]
	:
	\top
	\Rightarrow
	\forall \rvalL, \rvalR \in [0,1]^{\real}. ~
	\rvalL \leq \varx^1 \langle 1 \rangle \leq \rvalR 
			\imply
	(e^{\epsilon} \rvalL \leq \vary^1 \langle 2 \rangle \leq e^{\epsilon} \rvalR
	\land \vary^1 \langle 2 \rangle \leq 1)	
}~\textbf{unif+}
\]}}
	In this case, 
	assume $m_1, m_2$, $\rvalL, \rvalR \in (0,1]^{\real}$, s.t.,
	$(m_1, m_2) \in \sem{\Phi_0}$, where the precondition
	$
	\Phi_0 \triangleq
	\top
	$
	%
	is interpreted as:
	%
	\[
	\sem{\Phi_0} =
	\left \{
	(m_1, m_2)
	\right \}
	\]
	%
	%
	The post-condition $\Phi \triangleq 
		\rvalL \leq \varx^1 \langle 1 \rangle \leq \rvalR
		\imply
	e^{-\epsilon} \rvalL \leq \vary^1 \langle 2 \rangle \leq e^{\epsilon}\rvalR
	$ is interpreted as:
	%
	\[
	\sem{\Phi} =
	\left \{
	(m_1, m_2)
	~ \left \vert ~
	\forall \rvalL, \rvalR \in [0,1]^{\real}. ~
	\rvalL \leq \sem{\varx}_{\trsmem_1}^1 \leq \rvalR
	\imply
	(e^{\epsilon} \rvalL \leq \sem{\vary}_{\trsmem_2}^1 \leq e^{\epsilon}\rvalR
		\land \sem{\vary}_{\trsmem_2}^1 \leq 1)
	\right.
	\right \}
	\]
	%
	Let $(\fvalv_{(\rvalv_{l}, \rvalv_{u})}) = \sem{x}_{m_1}$ and 
	$(\fvalw_{(\rvalw_{l}, \rvalw_{u})}) = \sem{y}_{m_2}$, we can rewrite the interpretation of $\sem{\Phi}$ as:
	%
\[
	\sem{\Phi} =
	\left \{
	(m_1, m_2)
	~ \left \vert ~
	\begin{array}{l}
	(\fvalv_{(\rvalv_{l}, \rvalv_{u})}) = \sem{x}_{m_1}
	\land 
	(\fvalw_{(\rvalw_{l}, \rvalw_{u})}) = \sem{y}_{m_2}
	\land
	\\
	\forall \rvalL, \rvalR \in [0,1]^{\real}. ~
	\rvalL \leq \fvalv \leq \rvalR
	\imply
	(e^{\epsilon} \rvalL \leq 
		\fvalw \leq e^{\epsilon}\rvalR
		\land \fvalw \leq 1)
	\end{array}
	\right.
	\right \}
\]
	%
	By the semantics of sampling, we have:\\
	%
	$\sem{\varx \samplel \uniform(0, 1]}_{\trsmem_1} =
	\elet (\fvalv_{(\rvalv_{l}, \rvalv_{u})}) 
	= \sem{\uniform(0, 1]}_{\trsmem_1} 
	\ein 
	\unit{\trsmem_1[\varx \mapsto (\fvalv_{(\rvalv_{l}, \rvalv_{u})})]}
	$
	%
	\\
	%
	$\sem{\vary \samplel \uniform(0, 1]}_{\trsmem_2} = 
	\elet (\fvalw_{(\rvalw_{l}, \rvalw_{u})})
	= \sem{\uniform(0, 1]}_{\trsmem_2} 
	\ein 
	\unit{\trsmem_2[\vary \mapsto (\fvalw_{(\rvalw_{l}, \rvalw_{u})})]}
	$. \\
	%
	Then we need to prove:
	\[\mu_1(\trsmem_1) \sem{\Phi}^{\#(\epsilon)} \mu_2(\trsmem_2),\]
	where 
	$\mu_1(\trsmem) = 
	\elet (\fvalv_{(\rvalv_{l}, \rvalv_{u})}) 
	= \sem{\uniform(0, 1]}_{\trsmem} 
	\ein 
	\unit{\trsmem[\varx \mapsto (\fvalv_{(\rvalv_{l}, \rvalv_{u})})]}$ and
	%
	\\
	%
	$\mu_2(\trsmem) = 
	\elet (\fvalw_{(\rvalw_{l}, \rvalw_{u})})
	= \sem{\uniform(0, 1]}_{\trsmem} 
	\ein 
	\unit{\trsmem[\vary \mapsto (\fvalw_{(\rvalw_{l}, \rvalw_{u})})]}$.
	%
	\\
	%
	Now the following subproof is to show the subgoal:
	%
	\\
	\textbf{Subgoal:} For any pair of environments $(\trsmem_1, \trsmem_2)$, if we can show ${\muniform(0,1]} ~ R^{\#(\epsilon)} ~ {\muniform(0,1]}$, then $\mu_1(\trsmem_1) \sem{\Phi}^{\#(\epsilon)} \mu_2(\trsmem_2)$,
	%
	where
	\[
		R = 
		\left \{(\fval_1, \fval_2) \in \float \times \float 
		~\vert~
		\forall \rvalL, \rvalR \in [0,1]^{\real}. ~
		\rvalL \leq \fval_1 \leq \rvalR
		\imply
		(e^{\epsilon} \rvalL \leq \fval_2 \leq 	e^{\epsilon} \rvalR
		\land \fval_2 \leq 1)
		\right \}.
	\]	% \[
	% 	R = 
	% 	\left \{(\fval_1, \fval_2) \in (0,1]^\float \times (0,1]^\float 
	% 	~\vert~
	% 	\forall \rvalL, \rvalR \in [0,1]^{\real}. ~
	% 	\rvalL \leq \fval_1 \leq \rvalR
	% 	\imply
	% 	(e^{\epsilon} \rvalL \leq \fval_2 \leq 	e^{\epsilon} \rvalR
	% 	\land \fval_2 \leq 1)
	% 	\right \}.
	% \]
	%
	\begin{subproof}
	%
	It is equivalent to show following 3 items for any environment $\trsmem_1, \trsmem_2$:
	\\
	%
	(i) For any $\muniform(0,1]\in \distr(\float)$, there is one and only one $\edistr_1(\trsmem_1) \in \distr(Env)$.
	%
	\\
	(ii) For any $\muniform(0,1] \in \distr(\float)$, there is one and only one $\edistr_2(\trsmem_2) \in \distr(Env)$.
	\\
	%
	(iii) For any pair of float value $(\fvalv_1, \fvalv_2) \in R$ where 
	$\fvalv_1 \in \supp(\muniform(0,1])$, 
	$\fvalv_2 \in \supp(\muniform(0,1])$,
	there is one and only one pair of environments 
	$(\trsmem_1[ \varx_1 \to \fval_{1(\rval_{1l}, \rval_{1u})}], \trsmem_2[\varx_2 \to \fval_{2(\rval_{2l}, \rval_{2u})}]) \in \sem{\Phi}$
	where $\rval_{1l}, \rval_{1u}, \rval_{2l}, \rval_{2u} \in \real$.
	%
	\\ 
	%
	\textbf{Proof of (i):} 
	Given $\muniform(0,1]$, for any $\fval_1 \in \supp(\muniform(0,1])$, 
	we can always find one and only one $\fval_{1(\rval_{1l}, \rval_{1u})}$ where $\rval_{1l} = \fval_1 = \rval_{1u}$.
	%
	\\
	Then given environment $m_1$,
	we can construct one and only one $\sem{\uniform(0, 1)}_{\trsmem_1} \in \distr(\float_{\real \times \real})$
	by assigning the pdf on $\fval_{1(\rval_{1l}, \rval_{1u})}$ the same as $\pdf_{\muniform(0,1]}(\fval_1)$. 
	\\
	%
	Then we have the pdf of $\sem{\uniform(0, 1)}_{\trsmem_1}$  
	is defined as $\pdf_{\sem{\uniform(0, 1)}_{\trsmem_1}}$:
	%
	\[
	\pdf_{\sem{\uniform(0, 1)}_{\trsmem_1}}(\fval_{1(\rval_{1l}, \rval_{1u})}) = 
		\begin{cases}
		1 & \fval_1 \in (0,1]^{\mathbb{F}}
		\land  \fval_1 = \rval_{1l} = \rval_{1u}
		\\
		0       & o.w.
		\end{cases},
	\]
	Then by the Monad Law, we have the distribution:
	$\elet \fval_{1(\rval_{1l}, \rval_{1u})} = \sem{\uniform(0, 1)}_{\trsmem_1} 
	\ein \unit{\fval_{1(\rval_{1l}, \rval_{1u})}}$.
	% %
	\\
	%
	Since for any $\fval_{1(\rval_{1l}, \rval_{1u})} \in \sem{\uniform(0, 1)}_{\trsmem_1}$, 
	we can always construct one and only one environment $\trsmem_1[\varx_1 \mapsto (\fval_{1(\rval_{1l}, \rval_{1u})})]$.
	%
	\\
	Then we compose the  
	$\trsmem_1[\varx_1 \mapsto (\fval_{1(\rval_{1l}, \rval_{1u})})]$
	with $\elet \fval_{1(\rval_{1l}, \rval_{1u})} = \sem{\uniform(0, 1)}_{\trsmem_1} 
	\ein \unit{\fval_{1(\rval_{1l}, \rval_{1u})}}$ and get:
	%
	%
	$\mu_1(\trsmem_1) \in \distr(\float_{\real \times \real})$ as 
	$\elet \fval_{1(\rval_{1l}, \rval_{1u})} = \sem{\uniform(0, 1)}_{\trsmem_1} 
	\ein \unit{\trsmem_1[\varx_1 \mapsto (\fval_{1(\rval_{1l}, \rval_{1u})})]}$.
	\\
	%
	In this way, (i) are proved.
	\\
	%
	\textbf{Proof of (ii):} 
	We can also prove (ii) by repeating every steps above except substituting $\trsmem_1, \fvalv_1, \rvalv_{1l}$ and $\rvalv_{1u}$ with $\trsmem_2, \fvalv_2, \rvalv_{2l}$ and $\rvalv_{2u}$.
	%
	\\
	\textbf{Proof of (iii):} 
	Given any pair of float value $(\fvalv_1, \fvalv_2) \in R$ where 
	$\fvalv_1 \in \supp(\muniform(0,1])$, 
	$\fvalv_2 \in \supp(\muniform(0,1])$, we have by definition of $R$:
	%
	\\
	$\rvalL \leq \fvalv_1 \leq \rvalR \imply
	%
	(e^{\epsilon} \rvalL \leq \fval_2 \leq 	e^{\epsilon} \rvalR
	\land \fval_2 \leq 1)
	 ~ (3)$
	\\
	%
	By (i) and (ii), we can also construct one and only one pair of environments $\trsmem_1', \trsmem_2'$ as:
	\\
	$\trsmem_1' = \trsmem_1[\varx_1 \to \fval_{1(\rval_{1l}, \rval_{1u})}] ~ (4)$ and
	$\trsmem_2' = \trsmem_2[\varx_2 \to \fval_{2(\rval_{2l}, \rval_{2u})}] ~ (5)$,
	\\
	where $\rval_{1l} = \fval_1 = \rval_{1u}$ and $\rval_{2l} = \fval_2 = \rval_{2u}$.
	%
	\\
	In order to show $(\trsmem_1', \trsmem_2') \in \sem{\Phi}$, we need to prove:
	\\
	(a)	$(\fval_{1(\rval_{1l}, \rval_{1u})}) = \sem{x_1}_{m_1}$.
	This is proved by (5).
	\\
	(b) $(\fval_{2(\rval_{2l}, \rval_{2u})}) = \sem{x_2}_{m_2}$.
	This is proved by (6).
	\\
	(c) $\rvalL \leq \fvalv_1 \leq \rvalR \imply
	%
	(e^{\epsilon} \rvalL \leq \fval_2 \leq 	e^{\epsilon} \rvalR
	\land \fval_2 \leq 1)$.
	This is proved by (3).
	\\
	Then we have (iii) proved. 
	\end{subproof}
	%
	Since we have $\muniform(0,1] ~ R^{\#(\epsilon)} ~ \muniform(0,1]$ proved in the Theorem \ref{thm:unif+_coupling},
	%
	where 
	\[
		R = 
		\left \{(\fval_1, \fval_2) \in \float \times \float 
		~|~
		\forall \rvalL, \rvalR \in [0,1]^{\real}. ~
		\rvalL \leq \fval_1 \leq \rvalR
		\imply
		(e^{\epsilon} \rvalL \leq \fval_2 \leq 	e^{\epsilon} \rvalR
		\land \fval_2 \leq 1)
		\right \}.
	\]	%
	Then we have $\mu_1(\trsmem_1) \sem{\Phi}^{\#(\epsilon)} \mu_2(\trsmem_2)$ proved according to \textbf{Subgoal}.
	%
	\caseL{[\textsc{unif-}] }
	%
	The same as case [\textsc{unif+}].
		Since we have $\muniform(0,1] ~ R^{\#(\epsilon)} ~ \muniform(0,1]$ proved in the Theorem \ref{thm:unif-_coupling},
	%
	where 
	\[
		R = 
		\left \{(\fval_1, \fval_2) \in \float \times \float 
		~|~
		\forall \rvalL, \rvalR \in [0,1]^{\real}. ~
		\rvalL \leq \fval_1 \leq \rvalR
		\imply
		e^{-\epsilon} \rvalL \leq \fval_2 \leq 	e^{-\epsilon} \rvalR
		\right \}.
	\]
	%
	Then we have $\mu_1(\trsmem_1) \sem{\Phi}^{\#(\epsilon)} \mu_2(\trsmem_2)$ proved.
	%
	%
	\end{itemize}
\end{proof}
%
%
\newpage
\begin{thm}
\label{thm:unif+_coupling}
%
$${\muniform(0,1]} ~ R^{\#(\epsilon)} ~ {\muniform(0,1]},$$
%
where
	$	R = 
		\left \{(\varx, \vary) \in {\float} \times {\float} 
		~|~
		\forall \rvalL, \rvalR \in [0,1]^{\real}. ~
		\rvalL \leq \varx \leq \rvalR
		\imply
		(e^{\epsilon} \rvalL \leq \vary \leq 	e^{\epsilon} \rvalR
		\land \vary \leq 1)
		\right \}
		$.
	%
\end{thm}
%
\begin{proof}[Proof of Theorem \ref{thm:unif+_coupling}]
%
Let $\edistr_1 = \muniform(0, 1]$ and $\edistr_2 = \muniform(0, 1]$, it is equivalent to show 
${\edistr_1} ~ R^{\#(\epsilon)} ~ \edistr_2$.
%
%
%
\\
%
Let $\mu_L, \mu_R \in \distr\left({\float} \times {\float}\right)$ 
be the two witness distribution s.t.
their $\pdf.$ are defined as:
{\small\[
	\pdf_{\mu_L}(x, y) = 
	\begin{cases}
	\frac{1}{\left \vert (0, 1]^{\float} \right \vert} 
	& x = y \cdot e^{-\epsilon} \land x \in (0, e^{-\epsilon})\\
	\frac{1}{\left \vert (0, 1]^{\float} \right \vert} 	
	& x \in [e^{-\epsilon}, 1] \land y = 1\\
	0       
	& o.w.
	\end{cases};
~~~
	\pdf_{\mu_R}(x, y) = 
	\begin{cases}
	\frac{1}{\left \vert (0, 1]^{\float} \right \vert}	
	& x = y \cdot e^{-\epsilon} \land y \in (0, 1)\\
	\frac{1}{\left \vert [e^{-\epsilon}, 1]^{\float} \right \vert} \cdot \frac{1}{\left \vert (0, 1]^{\float} \right \vert}
	& x \in [e^{-\epsilon}, 1] \land y = 1\\
	0       & o.w.
	\end{cases}.
\]
}
It is enough to show that $\edistr_L(x, y)$ and $\edistr_R(x, y)$ are satisfying following three requirements:
\begin{itemize}
	\item $\supp(\mu_L) \subseteq R \land \supp(\mu_R) \subseteq R$
%
\\
%
Let $R' =
		\left \{(\varx, \vary) \in (0, 1]^{\float} \times (0, 1]^{\float} 
		~|~
		(\varx \in (0, e^{-\epsilon}) \imply \vary =  e^{\epsilon}  \varx)
		\land
		(\varx \in [e^{-\epsilon}, 1] \imply \vary = 1 )
		\right \}$.
		\\
		Since this implies $
		\forall \rvalL, \rvalR \in (0,1]^{\real}. (
		\rvalL \leq \varx \leq \rvalR
		\imply
		(e^{\epsilon} \rvalL \leq \vary \leq 	e^{\epsilon} \rvalR
		\land \vary \leq 1)$,
 we have $R' \subseteq R$.
%
%
	\begin{itemize}
		\item $\supp(\mu_L) \subseteq R$ 
		%
		\\
		% 
		By definition of the $\pdf$ of $\mu_L$, 
		$\supp(\mu_L) = \{(x, y) ~\vert~ \pdf_{\mu_L}(x, y) > 0\}$,
		we have: 
		\\
		$\supp(\mu_L) = \{(x, y) ~\vert~ 
		x = y \cdot e^{-\epsilon} \land x \in (0, e^{-\epsilon}) 
		\land x \in [e^{-\epsilon}, 1] \land y = 1
		\}$.
		\\  
		Then we know $\supp(\mu_L) \subseteq R'$.
		%
		\\
		%
		Since $R' \subseteq R$, 
		%
		we can then derive $\supp(\mu_L) \subseteq R$.
		%
		\item $\supp(\mu_R) \subseteq R$
		%
		\\
		%
		By definition of the $\pdf$ of $\mu_R$, 
		$\supp(\mu_R) = \{(x, y) ~\vert~ \pdf_{\mu_R}(x, y) > 0\}$,
		we have: 
		\\
		$\supp(\mu_R) = \{(x, y) ~\vert~ 
		x = y \cdot e^{-\epsilon} \land y \in (0, 1)
		\land
		x \in [e^{-\epsilon}, 1] \land y = 1 \}$
		\\  
		Then we know $\supp(\mu_R) \subseteq R'$. 
		%
		\\
		%
		Since $R' \subseteq R$, 
		%
		we can then derive $\supp(\mu_R) \subseteq R$.
		%
	\end{itemize}		
%
	\item $\projl(\mu_L) = \mu_1 \land \projr(\mu_R) = \mu_2$
	%
	\begin{itemize}
		\item $\projl(\mu_L) = \mu_1$ 
		\\
		% Equivalent to show $\pdf_{\projl(\mu_L)}  = \pdf_{\mu_1}$.
%
		By definition of the $\projl$ and $\pdf$ of $\mu_L$, we have $\forall x  \in \float$:
		\[
			\pdf_{\projl(\mu_L)}(x) = 
			\begin{cases}
			\sum_{y}\frac{1}{\left \vert (0, 1]^{\float} \right \vert} 
			& x = y \cdot e^{-\epsilon}  \land x \in (0, e^{-\epsilon})\\
			\sum_{y} \frac{1}{\left \vert (0, 1]^{\float} \right \vert} 
			& x \in [e^{-\epsilon}, 1] \land y = 1\\
			0       & o.w.
			\end{cases} 
			= 
			\begin{cases}
			\frac{1}{\left \vert (0, 1]^{\float} \right \vert}
			&  x \in (0, e^{-\epsilon})\\
			\frac{1}{\left \vert (0, 1]^{\float} \right \vert}
			& x \in [e^{-\epsilon}, 1] \\
			0       & o.w.
			\end{cases}
			=
			\pdf_{\mu_1}(x)
		\]

		\item $\projr(\mu_R) = \mu_2$ 
		%
		\\
		Equivalent to show$\pdf_{\projr(\mu_R)}  = \pdf_{\mu_2}$.
		\\
		%
		By definition of the $\projr$ and $\pdf$ of $\mu_R$, we have $\forall y \in \float$:
		%
		\[
			\pdf_{\projr(\mu_R)}(y) = 
			\begin{cases}
			\sum_{x} 
			\frac{1}{\left \vert (0, 1]^{\float} \right \vert} 
			& x = y \cdot e^{-\epsilon} \land y \in (0, 1)\\
			\sum_{x} 
			\frac{1}{\left \vert [e^{-\epsilon}, 1]^{\float} \right \vert} 
			\cdot
			\frac{1}{\left \vert (0, 1]^{\float} \right \vert} 
			& x \in [e^{-\epsilon}, 1] \land y = 1\\
			0       & o.w.
			\end{cases} 
			= 
			\begin{cases}
			\frac{1}{\left \vert (0, 1]^{\float} \right \vert}
			& y \in (0, 1)\\
			\frac{1}{\left \vert (0, 1]^{\float} \right \vert}  
			& y = 1\\
			0       & o.w.
			\end{cases}
			=
			\pdf_{\mu_2}(y)
		\]
	\end{itemize}	
%
	\item $\Delta_{\epsilon}(\mu_L, \mu_R) \leq 0$
%
\\
	By definition of $\epsilon-$DP divergence, we have:
	 \[
	 \begin{array}{ll}
	 \Delta_{\epsilon}(\mu_L, \mu_R) 
	 & = \underset{S}{\psup}
	 \Big(
	 \pr{(x,y) \samplel \mu_L}{(x,y) \in S} - e^{\epsilon} \pr{(x,y) \samplel \mu_R}{(x,y) \in S}
	 \Big) \\
	 & =\underset{S}{\psup}
	 \Big(
	 \sum_{(x,y) \in S} \pdf_{\mu_L}(x, y) - e^{\epsilon} \sum_{(x,y) \in S} \pdf_{\mu_R}(x, y)
	 \Big)	 
	 \end{array}
	 \]
	 \begin{itemize}
	 	\item[{\bf case}]
	 	%
	 	$S \subseteq \{(x, y) ~|~ 
	 	x = y \cdot e^{-\epsilon}  \land x \in (0, e^{-\epsilon}) \}$:
	 	%
		\[
		 \begin{array}{ll}
		 \Delta_{\epsilon}(\mu_L, \mu_R) 
		 & = 
		 \sum_{(x,y) \in S} \frac{1}{\left \vert (0, 1]^{\float} \right \vert})
		 - e^{\epsilon} \sum_{(x,y) \in S} \frac{1}{\left \vert (0, 1]^{\float} \right \vert}) \\ 
		 & = 
		 (1 - e^{\epsilon})\sum_{(x,y) \in S} \frac{1}{\left \vert (0, 1]^{\float} \right \vert} 
		 \leq 0 
		 \end{array}
		 \]
		 %
	 	\item[{\bf case}] $S \subseteq \{(x, y) 
	 	~|~ x \in [e^{-\epsilon}, 1] \land y = 1 \}$:
	 	%
		 \[
		 \begin{array}{ll}
		 \Delta_{\epsilon}(\mu_L, \mu_R) 
		 & = 
		 \sum_{(x,y) \in S} 
			\frac{1}{\left \vert (0, 1]^{\float} \right \vert} 
			 - 
		 e^{\epsilon} \sum_{(x,y) \in S} \frac{1}{\left \vert [e^{-\epsilon}, 1]^{\float} \right \vert} 
			\cdot
			\frac{1}{\left \vert (0, 1]^{\float} \right \vert} \\
		 %
		 &  = \frac{1}{\left \vert (0, 1]^{\float} \right \vert}
		 (1 - e^{\epsilon}) \leq 0
		 \end{array}
		 \]
		 %
	 	\item[{\bf case}] o.w.:
	 	%
		 \[
		 \Delta_{\epsilon}(\mu_L, \mu_R) = 0 - 0 =  0 
		 \]	 	

	 \end{itemize}

\end{itemize}
\end{proof}
%
%
\begin{thm}
\label{thm:unif-_coupling}
$${\muniform(0,1]} ~ R^{\#(\epsilon)} ~ {\muniform(0,1]},$$
%
where
	$R = 
		\left \{(\fval_1, \fval_2) \in {\float} \times {\float} 
		~|~
		\forall \rvalL, \rvalR \in (0,1]^{\real}.
		(\rvalL \leq \fval_1 \leq \rvalR
				\imply
				e^{-\epsilon} \rvalL \leq \fval_2 \leq 	e^{-\epsilon} \rvalR)
		\right \}	
		$.
	%
\end{thm}
%
\begin{proof}[Proof of Theorem \ref{thm:unif-_coupling}]
%
Let $\edistr_1 = \muniform(0, 1]$ and $\edistr_2 = \muniform(0, 1]$, it is equivalent to show 
${\edistr_1} ~ R^{\#(\epsilon)} ~ \edistr_2$.
%
\\
%
Let $R' =
		\left \{(\fval_1, \fval_2) \in {\float} \times {\float} 
		~|~
		\fval_2 =  e^{-\epsilon}  \fval_1
		\right \}$.
\\
Since $\fval_2 = e^{-\epsilon} \fval_1 \implies 
\forall \rvalL, \rvalR \in (0,1]^{\real}. (
\rvalL \leq \fval_1 \leq \rvalR
\imply
e^{-\epsilon} \rvalL \leq \fval_2 \leq 	e^{-\epsilon} \rvalR)$,
 we have $R' \implies R$.
%
\\
%
Let $\mu_L, \mu_R \in \distr(\float \times \float)$ 
be the two witness distribution s.t.:
% \[
% 	{\mu_L}(x, y) = 
% 	\begin{cases}
% 	\edistr_1(\varx)
% 	& x \cdot e^{-\epsilon} = y  \land x \in (0, 1]\\
% 	0       & o.w.
% 	\end{cases},
% ~~~
% 	{\mu_R}(x, y) = 
% 	\begin{cases}
% 	\edistr_2(y)
% 	& x \cdot e^{-\epsilon} = y \land y \in (0, 1]\\
% 	0       & o.w.
% 	\end{cases},
% \]
% %
% %
% and 
their $\pdf.$ are defined as:
\[
	\pdf_{\mu_L}(x, y) = 
	\begin{cases}
	\pdf_{\edistr_1}(x) & x \cdot e^{-\epsilon} = y  \land x \in [0, 1)\\
	0       & o.w.
	\end{cases},
~~~
	\pdf_{\mu_R}(x, y) = 
	\begin{cases}
	\pdf_{\edistr_2}(y) & x \cdot e^{-\epsilon} = y  \land y \in [0, 1)\\
	0       & o.w.
	\end{cases}.
\]
It is enough to show the 2 witnesses $\edistr_L(x, y)$ and $\edistr_R(x, y)$ are satisfying following three requirements:
\begin{itemize}
	\item $\supp(\mu_L) \subseteq R \land \supp(\mu_R) \subseteq R$
%
	\begin{itemize}
		\item $\supp(\mu_L) \subseteq R$ 
		%
		\\
		% 
		By definition of the $\pdf$ of $\mu_L$, 
		$\supp(\mu_L) = \{(x, y) ~\vert~ \pdf_{\mu_L}(x, y) > 0\}$,
		we have: 
		\\
		$\supp(\mu_L) = \{(x, y) ~\vert~ 
		x = y \cdot e^{-\epsilon} \land x \in (0, 1]\}$.
		\\  
		Then we know $\supp(\mu_L) \subseteq R'$.
		%
		%
		Since $R' \subseteq R$, 
		%
		we can then derive $\supp(\mu_L) \subseteq R$.
		%
		\item $\supp(\mu_R) \subseteq R$
		%
		\\
		%
		By definition of the $\pdf$ of $\mu_R$, 
		$\supp(\mu_R) = \{(x, y) ~\vert~ \pdf_{\mu_R}(x, y) > 0\}$,
		we have: 
		\\
		$\supp(\mu_R) = \{(x, y) ~\vert~ 
		x = y \cdot e^{-\epsilon} \land y \in (0, 1]\}$
		\\  
		Then we know $\supp(\mu_R) \subseteq R'$. 
		%
		%
		Since $R' \subseteq R$, 
		%
		we can then derive $\supp(\mu_R) \subseteq R$.
		%
	\end{itemize}		
%
	\item $\projl(\mu_L) = \mu_1 \land \projr(\mu_R) = \mu_2$
	
	\begin{itemize}
		\item $\projl(\mu_L) = \mu_1$ 

		% Equivalent to show $\pdf_{\projl(\mu_L)}  = \pdf_{\mu_1}$.

		By definition of the $\projl$ and $\pdf$ of $\mu_L$, we have $\forall x  \in \float$:
		\[
			\pdf_{\projl(\mu_L)}(x) = 
			\begin{cases}
			\sum_{y}\pdf_{\edistr_1}(x) 
			& x \cdot e^{-\epsilon}  = y 
			\land x \in [0, 1)\\
			0       & o.w.
			\end{cases} 
			= 
			\begin{cases}
			\pdf_{\edistr_1}(x) & \varx \in [0, 1)\\
			0       & o.w.
			\end{cases}
			=
			\pdf_{\mu_1}(x)
		\]

		\item $\projr(\mu_R) = \mu_2$ 

		Equivalent to show$\pdf_{\projr(\mu_R)}  = \pdf_{\mu_2}$.

		By definition of the $\projr$ and $\pdf$ of $\mu_R$, we have $\forall y \in \float$:
		\[
			\pdf_{\projr(\mu_R)}(y) = 
			\begin{cases}
			\sum_{x}\pdf_{\edistr_2}(y) 
			& x \cdot e^{-\epsilon} = y 
			\land y \in (0, 1]\\
			0       & o.w.
			\end{cases} 
			= 
			\begin{cases}
			\pdf_{\edistr_2}(y) & y \in (0, 1]\\
			0       & o.w.
			\end{cases}
			=
			\pdf_{\mu_2}(y)
		\]
	\end{itemize}	

	\item $\Delta_{\epsilon}(\mu_L, \mu_R) \leq 0$

	By definition of $\epsilon-$DP divergence, we have:
	 \[
	 \begin{array}{ll}
	 \Delta_{\epsilon}(\mu_L, \mu_R) 
	 & = \underset{S}{\psup}
	 \Big(
	 \pr{(x,y) \samplel \mu_L}{(x,y) \in S} - e^{\epsilon} \pr{(x,y) \samplel \mu_R}{(x,y) \in S}
	 \Big) \\
	 & =\underset{S}{\psup}
	 \Big(
	 \sum_{(x,y) \in S} \pdf_{\mu_L}(x, y) - e^{\epsilon} \sum_{(x,y) \in S} \pdf_{\mu_R}(x, y)
	 \Big)	 
	 \end{array}
	 \]
	 \begin{itemize}
	 	\item[{\bf case}]
	 	%
	 	$S \subseteq \{(x, y) ~|~ 
	 	x \in (0, 1] \land x \cdot e^{-\epsilon} = y \}$:
	 	%
		\[
		 \begin{array}{ll}
		 \Delta_{\epsilon}(\mu_L, \mu_R) 
		 & = 
		 \sum_{(x,y) \in S} \pdf_{\edistr_1}(x) - e^{\epsilon} \sum_{(x,y) \in S} \pdf_{\edistr_2}(y)\\
		 & = 
		 \sum_{(x,y) \in S} \pdf_{\edistr_1}(x) - e^{\epsilon} \sum_{(x,y) \in S} \pdf_{\edistr_2}(x * e^{-\epsilon})\\ 
		 & = 
		 \sum_{(x,y) \in S} \pdf_{\edistr_1}(x) - e^{\epsilon}* e^{-\epsilon} \sum_{(x,y) \in S} \pdf_{\edistr_1}(x) 
		 = 0 
		 \end{array}
		 \]
		 %
	 	\item[{\bf case}] $S \subseteq \{(x, y) 
	 	~|~ x \in [1, e^{\epsilon}) 
	 	\land x \cdot e^{-\epsilon} = y \}$:
	 	%
		 \[
		 \Delta_{\epsilon}(\mu_L, \mu_R) 
		 = 
		 0 - e^{\epsilon} \sum_{(x,y) \in S} \pdf_{\edistr_2}(y) <0
		 \]
	 	\item[{\bf case}] o.w.:
	 	%
		 \[
		 \Delta_{\epsilon}(\mu_L, \mu_R) = 0 - 0 =  0 
		 \]	 	

	 \end{itemize}

\end{itemize}
\end{proof}
%
%
%
%
\newpage
\section{Snapping Mechanism}

\begin{defn}
[$\snap(a) : A \to \distr(\real)$]
Given privacy parameter $\epsilon$, the Snapping mechanism $\snap(a)$ is defined as:
\[
	\varu \samplel \uniform(0,1); s \samplel \uniform\{-1, 1\};
	\varx = f(a) + \frac{1}{\epsilon} \times s \times \ln (\varu);
	\vary = \round{\varx}_{\Lambda};
	\varz = \clamp_B (\vary)
\]
where $f(a)$ represents a value that the query function $f$ be evaluated over input database $a \in A$, $\epsilon$ is the privacy parameter, $B$ is the clamping argument and $\Lambda$ is the rounding argument satisfying $\lambda = 2^k$ where $2^k$ is the smallest power of 2 greater or equal to the $\frac{1}{\epsilon}$.
\end{defn}
%
\begin{thm}[The $\snap$ mechanism is 
$\epsilon-$differentially private]
\end{thm}
\begin{proof}
Let $a, a'$ be two adjacent data bases, w.l.g., we consider the case where $f(a) = f(a') + 1$.
\\
Let $\valv$ be the identical output of $\snap(a)$ and $\snap(a')$, by inducting on the output space of $\snap(a)$ mechanism, we have following cases:
\begin{itemize}
	\caseL{$\boldsymbol{\varz = -B}$}
%
Let $b$ be the largest number rounded by $\Lambda$ that is smaller than $B$, $b' = b + \Lambda / 2$.
%
\\
Let $\rvalL_1 = \rvalL_2 = 0$, 
$\rvalR_1 = e^{\epsilon 
		(-(b + \Lambda / 2)(1 + \eta)^3 - f(a))(1 + \eta)^2}$
and $\rvalR_2 = e^{\epsilon 
		(-(b + \Lambda / 2)(1 + \eta) - f(a'))(1 + \eta)^2}$.
		\\
Then we have following derivation for this case:
%
{\tiny
\begin{mathpar}
\inferrule
{
	\inferrule
	{
	\inferrule
	{
		\inferrule
		{
			\forall \rvalL, \rvalR \in (0, 1]
		}
		{	\varu_1 \samplel \uniform(0,1)
			\sim_{\epsilon(1 + \eta)^2} 
			\varu_2 \samplel \uniform(0,1)
			: 
			f(a) = f(a') + 1
			\Rightarrow 
			\rvalL \leq u^1_1\langle 1 \rangle \leq \rvalR \imply 
			e^{\epsilon(1 + \eta)^2} \rvalL \leq u^1_2\langle 2 \rangle \leq e^{\epsilon(1 + \eta)^2}\rvalR
		}~\textbf{Unif+}
		\\ 
		f(a) = f(a') + 1 \Rightarrow f(a) = f(a') + 1
		\and
		\rvalL \leq u^1_1\langle 1 \rangle \leq \rvalR \imply 
		\Big(e^{\epsilon(1 + \eta)^2}\rvalL \leq u^1_2\langle 2 \rangle \leq e^{\epsilon(1 + \eta)^2}\rvalR \Big)
		\Rightarrow
		\Phi
	}
	{
		\varu_1 \samplel \uniform(0,1)
		\sim_{\epsilon(1 + \eta)^2} 
		\varu_2 \samplel \uniform(0,1)
		: 
		f(a) = f(a') + 1
		\Rightarrow 
		\Phi
	}~\textbf{Conseq}
	\and
	\inferrule
	{
	\empty
	}
	{
		s_1 = \samplel \uniform\{-1, 1\}
		\sim_{0} 
		s_2 = \samplel \uniform\{-1, 1\}
		: 
		\Phi
		\\\\
		\Rightarrow 
		\Phi \land s_1^1 \langle 1 \rangle
		= s_2^1\langle 2 \rangle
	}~\textbf{Null}
	}
	{
		\varu_1 \samplel \uniform(0,1); s_1 = \samplel \uniform\{-1, 1\}
		\sim_{\epsilon(\eta + 1)^2} 
		\varu_2 \samplel \uniform(0,1); s_2 = \samplel \uniform\{-1, 1\}
		: 
		f(a) = f(a') + 1 \Rightarrow \Phi \land s_1\langle 1 \rangle) 
		= s_2\langle 2 \rangle)
	}~\textbf{Seq}
\\
\Pi_R
}
{
	\vdash 
	\varu_1 \samplel \uniform(0,1); s_1 = \samplel \uniform\{-1, 1\};
	\varx_1 = f(a) + \frac{1}{\epsilon} \times s_1 \times \ln (\varu_1);
	\vary_1 = \round{\varx_1}_{\Lambda};
	\varz_1 = \clamp_B (\vary_1)
	\\
	\sim_{\epsilon(\eta + 1)^2} 
	\varu_2 \samplel \uniform(0,1); s_2 = \samplel \uniform\{-1, 1\};
	\varx_2 = f(a') + \frac{1}{\epsilon} \times s_2 \times \ln (\varu_2)
	\vary_2 = \round{\varx_2}_{\Lambda};
	\varz_2 = \clamp_B (\vary_2)
	: 
	f(a) = f(a') + 1
	\Rightarrow 
	\varz_1\langle 1 \rangle = -B \imply \varz_2\langle 2 \rangle = -B
}~\textbf{Seq}
\\
\Pi_R:
\\
\inferrule
{
\inferrule
{	
	\Phi \Rightarrow \Phi
	\and
	\inferrule
	{
		\empty
	}
	{
		\varx_1 = 
		f(a) + \frac{1}{\epsilon} \times s_1 \times \ln (\varu_1)
		\sim_{0} 
		\varx_2 =
		f(a') + \frac{1}{\epsilon} \times s_2 \times \ln (\varu_2)
		:
		\Phi \land s^1_1\langle 1 \rangle = s^1_2\langle 2 \rangle)
		\Rightarrow
		\Phi'
	}~\textbf{Assn}
	\and
	\Phi' \Rightarrow  0 < \Big(\varx_1\langle 1 \rangle\Big)^1 < -(b + \frac{\Lambda}{2} )
		\imply 
		0 < \Big(\varx_2\langle 2 \rangle \Big)^1 < -(b + \frac{\Lambda}{2} )
}
{
	\varx_1 = f(a) + \frac{1}{\epsilon} \times s_1 \times \ln (\varu_1)
	\sim_{0} 
	\varx_2 = f(a') + \frac{1}{\epsilon} \times s_2 \times \ln (\varu_2)
	:
	\Phi 
	\land s^1_1\langle 1 \rangle = s^1_2\langle 2 \rangle
	\Rightarrow 
	0 < \Big(\varx_1\langle 1 \rangle\Big)^1 < - (b + \frac{\Lambda}{2} )
		\imply 
		0 < \Big(\varx_2\langle 2 \rangle \Big)^1 < - (b + \frac{\Lambda}{2})
}~\textbf{Conseq}
\and
\Delta_R
}
{
	\varx_1 = f(a) + \frac{1}{\epsilon} \times s_1 \times \ln (\varu_1);
	\vary_1 = \round{\varx_1}_{\Lambda};
	\varz_1 = \clamp_B(\vary_1)
	\sim_{0} 
	\varx_2 = f(a') + \frac{1}{\epsilon} \times s_2 \times \ln (\varu_2);
	\vary_2 = \round{\varx_2}_{\Lambda};
	\varz_2 = \clamp_B(\vary_2)
	:
	f(a) = f(a') + 1 \land \Phi \land s_1\langle 1 \rangle) = s_2\langle 2 \rangle)
	\Rightarrow 
	\varz^1_1\langle 1 \rangle = -B
	\imply  = \varz_2^1\langle 2 \rangle) = -B
}~\textbf{Seq}
\\
\Delta_R:
\\
\inferrule
{
	\inferrule
	{
		\empty
	}
	{
		\vary_1 = \round{\varx_1}_{\Lambda}
		\sim_{0}
		\vary_2 = \round{\varx_2}_{\Lambda}
		: 
				0 < \Big(\varx_1\langle 1 \rangle\Big)^1 < - (b + \frac{\Lambda}{2} )
		\imply 
		0 < \Big(\varx_2\langle 2 \rangle \Big)^1 < - (b + \frac{\Lambda}{2})
		\\\\
		\Rightarrow 
		\vary^1_1\langle 1 \rangle < - (b + \Lambda) 
		\imply 
		\vary^1_2\langle 2 \rangle < - (b + \Lambda) 
	}~\textbf{Round}
	\and
	\inferrule
	{
		\empty
	}
	{
		\varz_1 = \clamp_B(\vary_1)
		\sim_{0}
		\varz_2 = \clamp_B(\vary_2)
		: 
		\vary^1_1\langle 1 \rangle < - (b + \Lambda) 
		\imply 
		\vary^1_2\langle 2 \rangle < - (b + \Lambda)
		\\\\  
		\Rightarrow 
			\varz^1_1\langle 1 \rangle = -B
	\imply  = \varz_2^1\langle 2 \rangle = -B
	}~\textbf{Null}
}
{
	\vary_1 = \round{\varx_1}_{\Lambda};
	\varz_1 = \clamp_B(\vary_1)
	\sim_{0} 
	\vary_2 = \round{\varx_2}_{\Lambda};
	\varz_2 = \clamp_B(\vary_2)
	:
		0 < \Big(\varx_1\langle 1 \rangle\Big)^1 < - (b + \frac{\Lambda}{2} )
		\imply 
		0 < \Big(\varx_2\langle 2 \rangle \Big)^1 < - (b + \frac{\Lambda}{2})
	\Rightarrow 
	\varz^1_1\langle 1 \rangle = -B
	\imply  = \varz_2^1\langle 2 \rangle = -B
}
\end{mathpar}
}
%
The assertion in the derivation is defined as:
\\
$\Phi \triangleq \rvalL_1 < 
u^1_1\langle 1 \rangle < \rvalR_1 \imply 
		\rvalL_2 < u^1_2\langle 2 \rangle < \rvalR_2$
\\
$\Phi' \triangleq 
\Phi[\varx_1/f(a) + \frac{1}{\epsilon} \times s_2 \times \ln (\varu_1), \varx_2/f(a') + \frac{1}{\epsilon} \times s_2 \times \ln (\varu_2)] $
%
\\
The $\Phi' \Rightarrow  0 < \Big(\varx_1\langle 1 \rangle\Big)^1 < -(b + \frac{\Lambda}{2} )
		\imply 
		0 < \Big(\varx_2\langle 2 \rangle \Big)^1 < -(b + \frac{\Lambda}{2} ) $ 
is proved as following:
%
\begin{subproof}
By the interpretation of assertion, we have $\sem{\Phi'}$:
\[
	\sem{\Phi'} \triangleq
	\left\{
	(\trsmem_1, \trsmem_2)
	\left \vert 
	0 < \sem{u_1}_{\trsmem_1} < \rvalR_1
	\imply
	0 < \sem{u_2}_{\trsmem_2} < \rvalR_2
	\right. \right\}
	\left[
	\varx_1/f(a) + \frac{1}{\epsilon} \times s_2 \times \ln (\varu_1), \varx_2/f(a') + \frac{1}{\epsilon} \times s_2 \times \ln (\varu_2) 
	\right]
\]

By the program semantics, we have the runtime environment $\trsmem_1, \trsmem_2$ as:
\\
{\tiny
\[
\begin{array}{ll}
	& \sem{\varu_1 \samplel \uniform(0,1); s_1 = \samplel \uniform\{-1, 1\};
		\varx_1 = f(a) + \frac{1}{\epsilon} \times s_1 \times \ln (\varu_1)}_{[]} =
	\\
	&
	 \elet (\fval_1, \rval_1, \rval_1 ) = \sem{\uniform(0,1)}_{[]} 
	 \ein \elet (1, 1, 1) = \sem{\uniform\{-1, 1\}} \ein
	 [\varu_1 \mapsto (\fval_1, \rval_1, \rval_1); 
	 s_1 \mapsto (1, 1, 1); 
	 \varx_1 \mapsto \bigg(
				f(a) + \frac{1}{\epsilon} \times \ln(u^1_1),
				%
				 (f(a) + 
				(\frac{1}{\epsilon} \times \ln(u^2_1))
				(1 + \eta)^2)
				{(1 + \eta)},
				%
				\frac{(
				f(a) + \frac{\frac{1}{\epsilon} 
				\times \ln(u^3_1)}
				{(1 + \eta)^2}
				)}
				{(1 + \eta)}
				\bigg)]
	\\
	\sim
	&
	\sem{\varu_2 \samplel \uniform(0,1); s_2 = \samplel \uniform\{-1, 1\};
		\varx_2 = f(a') + \frac{1}{\epsilon} \times s_2 \times \ln (\varu_2)}
	\\
	&
	\elet (\fval_2, \rval_2, \rval_2) = \sem{\uniform(0,1)}_{[]}
	\ein \elet (1, 1, 1) = \sem{\uniform\{-1, 1\}} \ein
	[\varu_2 \mapsto (\fval_2, \rval_2, \rval_2);
	 s_2 \mapsto (1, 1, 1); 
	 \varx_2 \mapsto \bigg(
				f(a) + \frac{1}{\epsilon} \times \ln(u^1_2),
						%
				\big( (f(a') + 
				(\frac{1}{\epsilon} \times \ln(u^2_2))
				(1 + \eta)^2)
				{(1 + \eta)},
				%
				\frac{(
				f(a') + \frac{\frac{1}{\epsilon} 
				\times \ln(u^3_2)}
				{(1 + \eta)^2}
				)}
				{(1 + \eta)}
				 \big)
				\bigg)]	
	\end{array}
\]
}
%
 We also have $\varu^1_1 = \varu^2_1 = \varu^3_1$, 
	$\varu^1_2 = \varu^2_2 = \varu^3_2$,
	$\varx^2_1 \leq \varx^1_1 \leq \varx^3_1$ and 
	$\varx^2_2 \leq \varx^1_2 \leq \varx^3_2$ by the semantics, 
	then we can get:
{\tiny
\[
\begin{array}{rcl}
	(f(a) + (\frac{1}{\epsilon} \times \ln(\rvalL_1))
	(1 + \eta)^2){(1 + \eta)}
	< \varx^1_1 < 
	\frac{(f(a) + \frac{\frac{1}{\epsilon} 
	\times \ln(\rvalR_1)}{(1 + \eta)^2})}{(1 + \eta)}
	& \imply &
	(f(a') + (\frac{1}{\epsilon} \times \ln(\rvalL_2))
	(1 + \eta)^2){(1 + \eta)} 
	< \varx^1_2 < 
	\frac{(f(a') + \frac{\frac{1}{\epsilon} 
	\times \ln(\rvalR_2)}{(1 + \eta)^2})}{(1 + \eta)}
	\\
	0 < \varx^1_1 <  b + \frac{\Lambda}{2}
	& \imply &
	0 < \varx^1_2 < b + \frac{\Lambda}{2}
	\end{array}
\]
}
Then, we have $\Phi' \Rightarrow  0 < \Big(\varx_1\langle 1 \rangle\Big)^1 < -(b + \frac{\Lambda}{2} )
		\imply 
		0 < \Big(\varx_2\langle 2 \rangle \Big)^1 < -(b + \frac{\Lambda}{2} ) $  proved.
\end{subproof}
%
%
\caseL{
	$\boldsymbol{\valv \in (-B, \round{f(a')}_{\Lambda})} ~ (\star) $
	}
	%
	\subcaseL{
	$\boldsymbol{\round{f(a')}_{\Lambda} \leq 0 
	\lor \bigg( \round{f(a')}_{\Lambda} > 0 \land \valv \in (-B, 0) \bigg) } ~ (\star_1)$
	}
	%
	Let $\valv_1 = \valv - (\frac{\Lambda}{2})$,
		$\valv_2 = \valv + (\frac{\Lambda}{2})$, 
		we know $\valv_1 < 0$, $\valv_2 < 0$.
\\
Let $\rvalL_1 = e^{\epsilon
		(\frac{(\frac{\valv_1}{1 + \eta} - f(a))}{(1 + \eta)^2})}$,
$\rvalL_2 = e^{\epsilon
		(\frac{(\frac{\valv_1}{1 + \eta} - f(a'))}{(1 + \eta)^2})}$, 
$\rvalR_1 = e^{\epsilon
				\big( (\valv_2(1 + \eta) - f(a)) (1 + \eta)^2) \big)}$
and $\rvalR_2 = e^{\epsilon
				\big( (\valv_2(1 + \eta) - f(a')) (1 + \eta)^2) \big)}$.
\\
Then, we have following derivation for this case:
%
{\tiny
\begin{mathpar}
\inferrule
{
	\inferrule
	{
	\inferrule
	{
		\inferrule
		{
			\forall \rvalL, \rvalR \in (0, 1]
		}
		{	\varu_1 \samplel \uniform(0,1)
			\sim_{\epsilon/(1 + \eta)^2} 
			\varu_2 \samplel \uniform(0,1)
			: 
			f(a) = f(a') + 1
			\Rightarrow 
			\rvalL \leq u^1_1\langle 1 \rangle \leq \rvalR \imply 
			e^{\epsilon(1 + \eta)^2} \rvalL \leq u^1_2\langle 2 \rangle \leq e^{\epsilon(1 + \eta)^2}\rvalR
		}~\textbf{Unif+}
		\\ 
		f(a) = f(a') + 1 \Rightarrow f(a) = f(a') + 1
		\and
		\rvalL \leq u^1_1\langle 1 \rangle \leq \rvalR \imply 
		\Big(e^{\epsilon/(1 + \eta)^2}\rvalL \leq u^1_2\langle 2 \rangle \leq e^{\epsilon/(1 + \eta)^2}\rvalR \Big)
		\Rightarrow
		\Phi
	}
	{
		\varu_1 \samplel \uniform(0,1)
		\sim_{\epsilon/(1 + \eta)^2} 
		\varu_2 \samplel \uniform(0,1)
		: 
		f(a) = f(a') + 1
		\Rightarrow 
		\Phi
	}~\textbf{Conseq}
	\and
	\inferrule
	{
	\empty
	}
	{
		s_1 = \samplel \uniform\{-1, 1\}
		\sim_{0} 
		s_2 = \samplel \uniform\{-1, 1\}
		: 
		\Phi
		\\\\
		\Rightarrow 
		\Phi \land s_1^1 \langle 1 \rangle
		= s_2^1\langle 2 \rangle
	}~\textbf{Null}
	}
	{
		\varu_1 \samplel \uniform(0,1); s_1 = \samplel \uniform\{-1, 1\}
		\sim_{\epsilon/(\eta + 1)^2} 
		\varu_2 \samplel \uniform(0,1); s_2 = \samplel \uniform\{-1, 1\}
		: 
		f(a) = f(a') + 1 \Rightarrow \Phi \land s_1\langle 1 \rangle) 
		= s_2\langle 2 \rangle)
	}~\textbf{Seq}
\\
\Pi_R
}
{
	\vdash 
	\varu_1 \samplel \uniform(0,1); s_1 = \samplel \uniform\{-1, 1\};
	\varx_1 = f(a) + \frac{1}{\epsilon} \times s_1 \times \ln (\varu_1);
	\vary_1 = \round{\varx_1}_{\Lambda};
	\varz_1 = \clamp_B (\vary_1)
	\\
	\sim_{\epsilon/(\eta + 1)^2} 
	\varu_2 \samplel \uniform(0,1); s_2 = \samplel \uniform\{-1, 1\};
	\varx_2 = f(a') + \frac{1}{\epsilon} \times s_2 \times \ln (\varu_2)
	\vary_2 = \round{\varx_2}_{\Lambda};
	\varz_2 = \clamp_B (\vary_2)
	: 
	f(a) = f(a') + 1
	\Rightarrow 
	\varz_1\langle 1 \rangle = v \imply \varz_2\langle 2 \rangle = v
}~\textbf{Seq}
\\
\Pi_R:
\\
\inferrule
{
\inferrule
{	
	\Phi \Rightarrow \Phi
	\and
	\inferrule
	{
		\empty
	}
	{
		\varx_1 = 
		f(a) + \frac{1}{\epsilon} \times s_1 \times \ln (\varu_1)
		\sim_{0} 
		\varx_2 =
		f(a') + \frac{1}{\epsilon} \times s_2 \times \ln (\varu_2)
		:
		\Phi \land s^1_1\langle 1 \rangle = s^1_2\langle 2 \rangle)
		\Rightarrow
		\Phi'
	}~\textbf{Assn}
	\and
	\Phi' \Rightarrow  v_1 < \Big(\varx_1\langle 1 \rangle\Big)^1 < v_2
		\imply 
		v_1 < \Big(\varx_2\langle 2 \rangle \Big)^1 < v_2
}
{
	\varx_1 = f(a) + \frac{1}{\epsilon} \times s_1 \times \ln (\varu_1)
	\sim_{0} 
	\varx_2 = f(a') + \frac{1}{\epsilon} \times s_2 \times \ln (\varu_2)
	:
	\Phi 
	\land s^1_1\langle 1 \rangle = s^1_2\langle 2 \rangle
	\Rightarrow 
	v_1 < \Big(\varx_1\langle 1 \rangle\Big)^1 < v_2
		\imply 
		v_1 < \Big(\varx_2\langle 2 \rangle \Big)^1 < v_2
}~\textbf{Conseq}
\and
\Delta_R
}
{
	\varx_1 = f(a) + \frac{1}{\epsilon} \times s_1 \times \ln (\varu_1);
	\vary_1 = \round{\varx_1}_{\Lambda};
	\varz_1 = \clamp_B(\vary_1)
	\sim_{0} 
	\varx_2 = f(a') + \frac{1}{\epsilon} \times s_2 \times \ln (\varu_2);
	\vary_2 = \round{\varx_2}_{\Lambda};
	\varz_2 = \clamp_B(\vary_2)
	:
	f(a) = f(a') + 1 \land \Phi \land s_1\langle 1 \rangle) = s_2\langle 2 \rangle)
	\Rightarrow 
	\varz^1_1\langle 1 \rangle = v
	\imply  = \varz_2^1\langle 2 \rangle) = v
}~\textbf{Seq}
\\
\Delta_R:
\\
\inferrule
{
	\inferrule
	{
		\empty
	}
	{
		\vary_1 = \round{\varx_1}_{\Lambda}
		\sim_{0}
		\vary_2 = \round{\varx_2}_{\Lambda}
		: 
				v_1 < \Big(\varx_1\langle 1 \rangle\Big)^1 < v_2
		\imply 
		v_1 < \Big(\varx_2\langle 2 \rangle \Big)^1 < v_2
		\\\\
		\Rightarrow 
		\vary^1_1\langle 1 \rangle = v 
		\imply 
		\vary^1_2\langle 2 \rangle = v
	}~\textbf{Round}
	\and
	\inferrule
	{
		\empty
	}
	{
		\varz_1 = \clamp_B(\vary_1)
		\sim_{0}
		\varz_2 = \clamp_B(\vary_2)
		: 
		\vary^1_1\langle 1 \rangle < - (b + \Lambda) 
		\imply 
		\vary^1_2\langle 2 \rangle < - (b + \Lambda)
		\\\\  
		\Rightarrow 
			\varz^1_1\langle 1 \rangle = v
	\imply  = \varz_2^1\langle 2 \rangle = v
	}~\textbf{Null}
}
{
	\vary_1 = \round{\varx_1}_{\Lambda};
	\varz_1 = \clamp_B(\vary_1)
	\sim_{0} 
	\vary_2 = \round{\varx_2}_{\Lambda};
	\varz_2 = \clamp_B(\vary_2)
	:
		0 < \Big(\varx_1\langle 1 \rangle\Big)^1 < - (b + \frac{\Lambda}{2} )
		\imply 
		0 < \Big(\varx_2\langle 2 \rangle \Big)^1 < - (b + \frac{\Lambda}{2})
	\Rightarrow 
	\varz^1_1\langle 1 \rangle = v
	\imply  = \varz_2^1\langle 2 \rangle = v
}
\end{mathpar}
}
%
The assertion in the derivation is defined as:
\\
$\Phi \triangleq \rvalL_1 < 
u^1_1\langle 1 \rangle < \rvalR_1 \imply 
		\rvalL_2 < u^1_2\langle 2 \rangle < \rvalR_2$
\\
$\Phi' \triangleq 
\Phi[\varx_1/f(a) + \frac{1}{\epsilon} \times s_2 \times \ln (\varu_1), \varx_2/f(a') + \frac{1}{\epsilon} \times s_2 \times \ln (\varu_2)] $
%
%
\subcaseL{
	$\boldsymbol{\round{f(a')}_{\Lambda} > 0 \land \valv \in (0, \round{f(a')}_{\Lambda}) } ~ (\star_1)$}
%
	Let $\valv_1 = \valv - (\frac{\Lambda}{2})$,
		$\valv_2 = \valv + (\frac{\Lambda}{2})$, 
		we know $\valv_1 > 0$, $\valv_2 > 0$.
\\
Let $\rvalL_1 = e^{\epsilon 
		(\frac{\valv_1}{1 + \eta} - \frac{f(a)}{(1 + \eta)^2})}$,
$\rvalL_2 = e^{\epsilon 
		(\frac{\valv_1}{1 + \eta} - \frac{f(a')}{(1 + \eta)^2})}$, 
$\rvalR_1 = e^{\epsilon 
				\big( \valv_2(1 + \eta) - f(a) (1 + \eta)^2) \big)}$
and $\rvalR_2 = e^{\epsilon 
				\big( \valv_2(1 + \eta) - f(a') (1 + \eta)^2) \big)}$.
	By the calculation in the Flopt Version proof, we have:
	\[
		e^0 < \frac{\rvalR_1 - \rvalL_1}{\rvalR_2 - \rvalL_2}
		\leq e^{\epsilon(12 \eta B + 1)}.
	\]
Then, we can instantiate the $\textbf{unif+}$ rule as:
{\scriptsize
\begin{mathpar}
	\inferrule
	{
		\inferrule
		{
			\forall \rvalL, \rvalR \in (0, 1]
		}
		{	\varu_1 \samplel \uniform(0,1)
			\sim_{\epsilon(12 \eta B + 1)} 
			\varu_2 \samplel \uniform(0,1)
			: 
			f(a) = f(a') + 1
			\Rightarrow 
			\rvalL \leq u^1_1\langle 1 \rangle \leq \rvalR \imply 
			e^{\epsilon(12 \eta B + 1)} \rvalL \leq u^1_2\langle 2 \rangle \leq e^{\epsilon(12 \eta B + 1)}\rvalR
		}~\textbf{Unif+}
		\\ 
		f(a) = f(a') + 1 \Rightarrow f(a) = f(a') + 1
		\and
		\rvalL \leq u^1_1\langle 1 \rangle \leq \rvalR \imply 
		\Big(e^{\epsilon(12 \eta B + 1)}\rvalL \leq u^1_2\langle 2 \rangle \leq e^{\epsilon(12 \eta B + 1)}\rvalR \Big)
		\Rightarrow
		\rvalL_1 < 
u^1_1\langle 1 \rangle < \rvalR_1 \imply 
		\rvalL_2 < u^1_2\langle 2 \rangle < \rvalR_2
	}
	{
		\varu_1 \samplel \uniform(0,1)
		\sim_{\epsilon(12 \eta B + 1)} 
		\varu_2 \samplel \uniform(0,1)
		: 
		f(a) = f(a') + 1
		\Rightarrow 
		\rvalL_1 < 
		u^1_1\langle 1 \rangle < \rvalR_1 \imply 
		\rvalL_2 < u^1_2\langle 2 \rangle < \rvalR_2
	}~\textbf{Conseq}
\end{mathpar}
}
Then, we have the following derivation exactly the same as previous cases.
%
%
\subcaseL{$\boldsymbol{\round{f(a')}_{\Lambda} > 0 \land \valv = 0 } $}
	%
	Let $\valv_1 = \valv - (\frac{\Lambda}{2})$,
	$\valv_2 = \valv  + (\frac{\Lambda}{2})$,
	we know $\valv_1 < 0$, $\valv_2 > 0$.
	By \textbf{Lemma 3} from the Flopt Version we have: $s = 1$.	%
	\\
	Let $\rvalL_1 = e^{\epsilon 
		(\frac{\valv_1}{(1 + \eta)^3} - \frac{f(a)}{(1 + \eta)^2})}$,
	$\rvalL_2 = e^{\epsilon 
		(\frac{\valv_1}{(1 + \eta)^3} - \frac{f(a')}{(1 + \eta)^2})}$, 
	$\rvalR_1 = e^{\epsilon 
					\big(\valv_2(1 + \eta) - f(a) (1 + \eta)^2) \big)}$
	and $\rvalR_2 = e^{\epsilon 
					\big(\valv_2(1 + \eta) - f(a') (1 + \eta)^2) \big)}$.
	By the calculation in the Flopt Version proof, we have:
	\[
		e^0 < \frac{\rvalR_1 - \rvalL_1}{\rvalR_2 - \rvalL_2}
		\leq e^{\epsilon(14 \eta B + 1)}.
	\]
	%
	%
Then, we can instantiate the $\textbf{unif+}$ rule as:
{\scriptsize
\begin{mathpar}
	\inferrule
	{
		\inferrule
		{
			\forall \rvalL, \rvalR \in (0, 1]
		}
		{	\varu_1 \samplel \uniform(0,1)
			\sim_{\epsilon(14 \eta B + 1)} 
			\varu_2 \samplel \uniform(0,1)
			: 
			f(a) = f(a') + 1
			\Rightarrow 
			\rvalL \leq u^1_1\langle 1 \rangle \leq \rvalR \imply 
			e^{\epsilon(14 \eta B + 1)} \rvalL \leq u^1_2\langle 2 \rangle \leq e^{\epsilon(14 \eta B + 1)}\rvalR
		}~\textbf{Unif+}
		\\ 
		f(a) = f(a') + 1 \Rightarrow f(a) = f(a') + 1
		\and
		\rvalL \leq u^1_1\langle 1 \rangle \leq \rvalR \imply 
		\Big(e^{\epsilon(14 \eta B + 1)}\rvalL \leq u^1_2\langle 2 \rangle \leq e^{\epsilon(14 \eta B + 1)}\rvalR \Big)
		\Rightarrow
		\rvalL_1 < 
u^1_1\langle 1 \rangle < \rvalR_1 \imply 
		\rvalL_2 < u^1_2\langle 2 \rangle < \rvalR_2
	}
	{
		\varu_1 \samplel \uniform(0,1)
		\sim_{\epsilon(14 \eta B + 1)} 
		\varu_2 \samplel \uniform(0,1)
		: 
		f(a) = f(a') + 1
		\Rightarrow 
		\rvalL_1 < 
		u^1_1\langle 1 \rangle < \rvalR_1 \imply 
		\rvalL_2 < u^1_2\langle 2 \rangle < \rvalR_2
	}~\textbf{Conseq}
\end{mathpar}
}
Then, we have the following derivation exactly the same as previous cases.
	%
	\caseL{$\boldsymbol{\valv = \round{f(a')}_{\Lambda}}$}
	%
	There are 3 subcases by induction on $\round{f(a')}_{\Lambda}$:
	$\round{f(a')}_{\Lambda} < 0$, $\round{f(a')}_{\Lambda} = 0$ and $\round{f(a')}_{\Lambda} > 0$. 
		\\
		%
	Without loss of generalization, 
	we consider the worst case where the error propagate in the same direction, i.e. $\round{f(a')}_{\Lambda} < 0$.
		%
		\\
		%
	Let $\valv_1 = \valv - \frac{\Lambda}{2}$, $\valv_2 = \valv + \frac{\Lambda}{2}$, we know $\valv_1 < 0$, $\valv_2 < 0$.
		%
	By \textbf{ Lemma. 3}, \textbf{ Lemma. 7 and  8} from the Flopt Version, we have:
	$s = 1$ or $-1$ and $\rvalR_2 = 1$.
	%
	\\
	%
	Let $\rvalL_1 = e^{\epsilon 
			(\frac{(\frac{\valv_1}{1 + \eta} - f(a))}{(1 + \eta)^2})}$,
	$\rvalL_2 = e^{\epsilon 
			(\frac{(\frac{\valv_1}{1 + \eta} - f(a'))}{(1 + \eta)^2})}$, 
	$\rvalR_1 = e^{\epsilon 
					\big((\valv_2(1 + \eta) - f(a)) (1 + \eta)^2) \big)}$
	and $\rvalR_2 = 1$.
	By the calculation in the Flopt Version proof, we have:
	\[
		e^0 < \frac{\rvalR_1 - \rvalL_1}{\rvalR_2 - \rvalL_2}
		\leq e^{\epsilon(12 \eta B + 1)} .
	\]
	%
	\\	
	%
	Then we have the derivation exactly the same as previous cases.
	%
	%
	\caseL{
	$\boldsymbol{\valv \in (\round{f(a')}_{\Lambda}, \round{f(a)}_{\Lambda})}$
	}
	%
	Let $\valv_1 = \valv - \frac{\Lambda}{2}$, $\valv_2 = \valv + \frac{\Lambda}{2}$. 
	\\
	According to the computation in the floating point version, let 
	%
	 $\rvalL_1 = e^{\epsilon 
			(\frac{(\frac{\valv_1}{1 + \eta} - f(a))}{(1 + \eta)^2})}$,
	$\rvalL_2 = e^{\epsilon 
			(\frac{(f(a') - \frac{\valv_1}{1 + \eta})}{(1 + \eta)^2})}$, 
	$\rvalR_1 = e^{\epsilon 
					\big((\valv_2(1 + \eta) - f(a)) (1 + \eta)^2) \big)}$
	and $\rvalR_2 = e^{\epsilon 
					\big((f(a') - \valv_2(1 + \eta)) (1 + \eta)^2) \big)}$.
	we have:
	\[
		e^0 > \frac{\rvalR_1 - \rvalL_1}{\rvalR_2 - \rvalL_2}
		\geq e^{-\epsilon(23 \eta B + 1)} .
	\]
	%
	\\	
	%
	Then we have the derivation exactly the same as previous cases.
	%
	%
	\caseL{$\boldsymbol{\valv = \round{f(a)}_{\Lambda}}$}
	%
	%
	There are 3 subcases by induction on $\round{f(a')}_{\Lambda}$:
	$\round{f(a)}_{\Lambda} < 0$, $\round{f(a)}_{\Lambda} = 0$ and $\round{f(a)}_{\Lambda} > 0$. 
		\\
		%
	Without loss of generalization, 
	we consider the worst case where the error propagate in the same direction, i.e. $\round{f(a)}_{\Lambda} < 0$.
		%
		\\
		%
	Let $\valv_1 = \valv - \frac{\Lambda}{2}$, $\valv_2 = \valv + \frac{\Lambda}{2}$, we know $\valv_1 < 0$, $\valv_2 < 0$.
		%
	By \textbf{ Lemma. 3}, \textbf{ Lemma. 7 and  8} from the Flopt Version, we have:
	$s = 1$ or $-1$ and $\rvalR_2 = 1$.
	%
	\\
	%
	Let $\rvalL_1 = e^{\epsilon 
			(\frac{(\frac{\valv_1}{1 + \eta} - f(a))}{(1 + \eta)^2})}$,
	$\rvalL_2 = e^{\epsilon 
			(\frac{(\frac{\valv_1}{1 + \eta} - f(a'))}{(1 + \eta)^2})}$, 
	$\rvalR_1 = e^{\epsilon 
					\big((\valv_2(1 + \eta) - f(a)) (1 + \eta)^2) \big)}$
	and $\rvalR_2 = 1$.
	By the calculation in the Flopt Version proof, we have:
	\[
		e^0 > \frac{\rvalR_1 - \rvalL_1}{\rvalR_2 - \rvalL_2}
		\geq e^{-\epsilon(24 \eta B + 1)} .
	\]
	%
	\\	
	%
	Then we have the derivation exactly the same as previous cases.
	%
	%
	\caseL{$\boldsymbol{\valv \in  (\round{f(a)}_{\Lambda}, B)}$}
	%
	%
	\subcaseL{
	$\boldsymbol{\round{f(a)}_{\Lambda} > 0 \lor \round{f(a)}_{\Lambda} < 0 \land \valv \in  (0, B)}$}
	%
	Let $\valv_1 = \valv - (\frac{\Lambda}{2})$,
		$\valv_2 = \valv + (\frac{\Lambda}{2})$, 
		we know $\valv_1 > 0$, $\valv_2 > 0$.
	\\
	Let $\rvalL_1 = e^{\epsilon 
			(\frac{f(a)}{(1 + \eta)^2} - \frac{\valv_1}{1 + \eta})}$,
	$\rvalL_2 = e^{\epsilon 
			(\frac{f(a')}{(1 + \eta)^2} - \frac{\valv_1}{1 + \eta})}$, 
	$\rvalR_1 = e^{\epsilon 
					\big( f(a) (1 + \eta)^2 - \valv_2(1 + \eta) \big)}$
	and $\rvalR_2 = e^{\epsilon 
					\big( f(a') (1 + \eta)^2 - \valv_2(1 + \eta) \big)}$.
		By the calculation in the Flopt Version proof, we have:
		\[
			e^0 < \frac{\rvalR_1 - \rvalL_1}{\rvalR_2 - \rvalL_2}
			\leq e^{\epsilon(12 \eta B + 1)}.
		\]
	Then, we can instantiate the $\textbf{unif-}$ rule as:
	{\scriptsize
	\begin{mathpar}
		\inferrule
		{
			\inferrule
			{
				\forall \rvalL, \rvalR \in (0, 1]
			}
			{	\varu_1 \samplel \uniform(0,1)
				\sim_{\epsilon(12 \eta B + 1)} 
				\varu_2 \samplel \uniform(0,1)
				: 
				f(a) = f(a') + 1
				\Rightarrow 
				\rvalL \leq u^1_1\langle 1 \rangle \leq \rvalR \imply 
				e^{-\epsilon(12 \eta B + 1)} \rvalL \leq u^1_2\langle 2 \rangle \leq e^{-\epsilon(12 \eta B + 1)}\rvalR
			}~\textbf{Unif-}
			\\ 
			f(a) = f(a') + 1 \Rightarrow f(a) = f(a') + 1
			\and
			\rvalL \leq u^1_1\langle 1 \rangle \leq \rvalR \imply 
			\Big(e^{-\epsilon(12 \eta B + 1)}\rvalL \leq u^1_2\langle 2 \rangle \leq e^{-\epsilon(12 \eta B + 1)}\rvalR \Big)
			\Rightarrow
			\rvalL_1 < 
	u^1_1\langle 1 \rangle < \rvalR_1 \imply 
			\rvalL_2 < u^1_2\langle 2 \rangle < \rvalR_2
		}
		{
			\varu_1 \samplel \uniform(0,1)
			\sim_{\epsilon(12 \eta B + 1)} 
			\varu_2 \samplel \uniform(0,1)
			: 
			f(a) = f(a') + 1
			\Rightarrow 
			\rvalL_1 < 
			u^1_1\langle 1 \rangle < \rvalR_1 \imply 
			\rvalL_2 < u^1_2\langle 2 \rangle < \rvalR_2
		}~\textbf{Conseq}
	\end{mathpar}
	}
	Then, we have the rest derivation exactly the same as previous cases.
	%
	%
	%
	\subcaseL{$\boldsymbol{\round{f(a)}_{\Lambda} < 0 \land \valv \in  (\round{f(a)}_{\Lambda}, 0)}$}
	%
	%
	Let $\valv_1 = \valv - (\frac{\Lambda}{2})$,
		$\valv_2 = \valv + (\frac{\Lambda}{2})$, 
		we know $\valv_1 < 0$, $\valv_2 < 0$.
	\\
	Let $\rvalL_1 = e^{\epsilon 
			(\frac{f(a)}{(1 + \eta)^2} - \frac{\valv_1}{(1 + \eta)^3})}$,
	$\rvalL_2 = e^{\epsilon 
			(\frac{f(a')}{(1 + \eta)^2} - \frac{\valv_1}{(1 + \eta)^3})}$, 
	$\rvalR_1 = e^{\epsilon 
					\big(f(a) (1 + \eta)^2 - \valv_2(1 + \eta)^3 \big)}$
	and $\rvalR_2 = e^{\epsilon 
					\big(f(a') (1 + \eta)^2 - \valv_2(1 + \eta)^3\big)}$.
		By the calculation in the Flopt Version proof, we have:
		\[
			e^0 < \frac{\rvalR_1 - \rvalL_1}{\rvalR_2 - \rvalL_2}
			\leq e^{\epsilon(12 \eta B + 1)}.
		\]
	Then, we can instantiate the $\textbf{unif-}$ rule as:
	{\scriptsize
	\begin{mathpar}
		\inferrule
		{
			\inferrule
			{
				\forall \rvalL, \rvalR \in (0, 1]
			}
			{	\varu_1 \samplel \uniform(0,1)
				\sim_{\epsilon(12 \eta B + 1)} 
				\varu_2 \samplel \uniform(0,1)
				: 
				f(a) = f(a') + 1
				\Rightarrow 
				\rvalL \leq u^1_1\langle 1 \rangle \leq \rvalR \imply 
				e^{-\epsilon(12 \eta B + 1)} \rvalL \leq u^1_2\langle 2 \rangle \leq e^{-\epsilon(12 \eta B + 1)}\rvalR
			}~\textbf{Unif-}
			\\ 
			f(a) = f(a') + 1 \Rightarrow f(a) = f(a') + 1
			\and
			\rvalL \leq u^1_1\langle 1 \rangle \leq \rvalR \imply 
			\Big(e^{-\epsilon(12 \eta B + 1)}\rvalL \leq u^1_2\langle 2 \rangle \leq e^{-\epsilon(12 \eta B + 1)}\rvalR \Big)
			\Rightarrow
			\rvalL_1 < 
	u^1_1\langle 1 \rangle < \rvalR_1 \imply 
			\rvalL_2 < u^1_2\langle 2 \rangle < \rvalR_2
		}
		{
			\varu_1 \samplel \uniform(0,1)
			\sim_{\epsilon(12 \eta B + 1)} 
			\varu_2 \samplel \uniform(0,1)
			: 
			f(a) = f(a') + 1
			\Rightarrow 
			\rvalL_1 < 
			u^1_1\langle 1 \rangle < \rvalR_1 \imply 
			\rvalL_2 < u^1_2\langle 2 \rangle < \rvalR_2
		}~\textbf{Conseq}
	\end{mathpar}
	}
	Then, we have the rest derivation exactly the same as previous cases.
	%
	%
	\subcaseL{$\boldsymbol{\round{f(a)}_{\Lambda} < 0 \land \valv = 0}$}
	%
	%
	Let $\valv_1 = \valv - (\frac{\Lambda}{2})$,
	$\valv_2 = \valv  + (\frac{\Lambda}{2})$,
	we know $\valv_1 < 0$, $\valv_2 > 0$.
	By \textbf{Lemma 3} from the Flopt Version we have: $s = 1$.	%
	\\
	Let $\rvalL_1 = e^{\epsilon 
		(\frac{f(a)}{(1 + \eta)^2} - \frac{\valv_1}{(1 + \eta)^3})}$,
	$\rvalL_2 = e^{\epsilon 
		(\frac{f(a')}{(1 + \eta)^2} - \frac{\valv_1}{(1 + \eta)^3})}$, 
	$\rvalR_1 = e^{\epsilon 
				\big( f(a) (1 + \eta)^2 - \valv_2(1 + \eta)) \big)}$
	and $\rvalR_2 = e^{\epsilon 
			\big( f(a') (1 + \eta)^2 - \valv_2(1 + \eta)) \big)}$.
	%
	%
Then, we can instantiate the $\textbf{unif-}$ rule as:
{\scriptsize
\begin{mathpar}
	\inferrule
	{
		\inferrule
		{
			\forall \rvalL, \rvalR \in (0, 1]
		}
		{	\varu_1 \samplel \uniform(0,1)
			\sim_{\epsilon(1 + \eta)^2} 
			\varu_2 \samplel \uniform(0,1)
			: 
			f(a) = f(a') + 1
			\Rightarrow 
			\rvalL \leq u^1_1\langle 1 \rangle \leq \rvalR \imply 
			e^{-\epsilon(1 + \eta)^2} \rvalL \leq u^1_2\langle 2 \rangle \leq e^{-\epsilon(1 + \eta)^2}\rvalR
		}~\textbf{Unif-}
		\\ 
		f(a) = f(a') + 1 \Rightarrow f(a) = f(a') + 1
		\and
		\rvalL \leq u^1_1\langle 1 \rangle \leq \rvalR \imply 
		\Big(e^{-\epsilon(1 + \eta)^2}\rvalL \leq u^1_2\langle 2 \rangle \leq e^{-\epsilon(1 + \eta)^2}\rvalR \Big)
		\Rightarrow
		\rvalL_1 < 
u^1_1\langle 1 \rangle < \rvalR_1 \imply 
		\rvalL_2 < u^1_2\langle 2 \rangle < \rvalR_2
	}
	{
		\varu_1 \samplel \uniform(0,1)
		\sim_{\epsilon(1 + \eta)^2} 
		\varu_2 \samplel \uniform(0,1)
		: 
		f(a) = f(a') + 1
		\Rightarrow 
		\rvalL_1 < 
		u^1_1\langle 1 \rangle < \rvalR_1 \imply 
		\rvalL_2 < u^1_2\langle 2 \rangle < \rvalR_2
	}~\textbf{Conseq}
\end{mathpar}
}
Then, we have the rest derivation exactly the same as previous cases.
	%
	\caseL{$\boldsymbol{\valv = B}$}
	%
	Let $b$ be the largest number rounded by $\Lambda$ that is smaller than $B$.
%
\\
Let $\rvalL_1 = \rvalL_2 = 0$, 
$\rvalR_1 = e^{\epsilon 
		(f(a) - (b + \Lambda / 2)/(1 + \eta))(1 + \eta)^2}$
and $\rvalR_2 = e^{\epsilon 
		(f(a') - (b + \Lambda / 2)/(1 + \eta))(1 + \eta)^2}$.
		\\
Then, we can instantiate the $\textbf{unif-}$ rule as:
%
{\tiny
\begin{mathpar}
	\inferrule
	{
		\inferrule
		{
			\forall \rvalL, \rvalR \in (0, 1]
		}
		{	\varu_1 \samplel \uniform(0,1)
			\sim_{\epsilon(1 + \eta)^2} 
			\varu_2 \samplel \uniform(0,1)
			: 
			f(a) = f(a') + 1
			\Rightarrow 
			\rvalL \leq u^1_1\langle 1 \rangle \leq \rvalR \imply 
			\Big(e^{-\epsilon(1 + \eta)^2}\rvalL \leq u^1_2\langle 2 \rangle \leq e^{-\epsilon(1 + \eta)^2} \land u^1_2\langle 2 \rangle \leq \rvalR \Big)
		}~\textbf{Unif-}
		\\ 
		f(a) = f(a') + 1 \Rightarrow f(a) = f(a') + 1
		\and
		\rvalL \leq u^1_1\langle 1 \rangle \leq \rvalR 
		\imply 
		\Big(e^{-\epsilon(1 + \eta)^2}\rvalL \leq u^1_2\langle 2 \rangle \leq e^{-\epsilon(1 + \eta)^2} \land u^1_2\langle 2 \rangle \leq \rvalR \Big)
		\Rightarrow
		0 < u^1_1\langle 1 \rangle < \rvalR_1 \imply 
		0 < u^1_2\langle 2 \rangle < \rvalR_2
	}
	{
		\varu_1 \samplel \uniform(0,1)
		\sim_{\epsilon(1 + \eta)^2} 
		\varu_2 \samplel \uniform(0,1)
		: 
		f(a) = f(a') + 1
		\Rightarrow 
		0 < u^1_1\langle 1 \rangle < \rvalR_1 \imply 
		0 < u^1_2\langle 2 \rangle < \rvalR_2
	}~\textbf{Conseq}
\end{mathpar}
}
Then, we have the rest derivation exactly the same as previous cases.
\end{itemize}


\end{proof}

\section{Application Examples}

\subsection{Partial Sum Algorithm}
%
\begin{algorithm}
\footnotesize
\caption{Partial Sum Algorithm}
\label{alg:partialsum}
\begin{algorithmic}
\REQUIRE Database
\STATE Define control dataset $C = \{0,1, \cdots, c - 1\}$
\STATE 
\STATE  {\bf for}\ $j\in [k]$\ {\bf do} 
\STATE \qquad {\bf let} $p=\uniform(0,1)$ 
\STATE \qquad {\bf define} $q (x) = \bernoulli ( p )$ .
\STATE \qquad {\bf define} $qc (x) = \bernoulli ( p )$ .
\STATE \qquad {\bf let} $a = \mathcal{M}(q)$ 
\STATE \qquad {\bf for}\ $i \in [N]$\ {\bf do}
\STATE \qquad \qquad $Nscore(i) = Nscore(i) + (a - p)*(q (i) - p)$ if $i \notin I$
\STATE \qquad {\bf for}\ $i \in [c]$\ {\bf do}
\STATE \qquad \qquad $Cscore(C(i)) = Cscore(C(i)) + (a - p)*(qc (i) - p)$
\STATE \qquad {\bf let} $I = \{i | i\in [N] \land Nscore(i) > \max(Cscore)\}$
\STATE \qquad {\bf let} $X = X \setminus I$ 
\RETURN $X$.
% \ENSURE 
\end{algorithmic}
\end{algorithm}
%
\subsection{Above Threshold Algorithm}
%
\begin{algorithm}
\footnotesize
\caption{Above Threshold Algorithm}
\label{alg:abovethd}
\begin{algorithmic}
\REQUIRE Database
\STATE Define control dataset $C = \{0,1, \cdots, c - 1\}$
\STATE 
\STATE  {\bf for}\ $j\in [k]$\ {\bf do} 
\STATE \qquad {\bf let} $p=\uniform(0,1)$ 
\STATE \qquad {\bf define} $q (x) = \bernoulli ( p )$ .
\STATE \qquad {\bf define} $qc (x) = \bernoulli ( p )$ .
\STATE \qquad {\bf let} $a = \mathcal{M}(q)$ 
\STATE \qquad {\bf for}\ $i \in [N]$\ {\bf do}
\STATE \qquad \qquad $Nscore(i) = Nscore(i) + (a - p)*(q (i) - p)$ if $i \notin I$
\STATE \qquad {\bf for}\ $i \in [c]$\ {\bf do}
\STATE \qquad \qquad $Cscore(C(i)) = Cscore(C(i)) + (a - p)*(qc (i) - p)$
\STATE \qquad {\bf let} $I = \{i | i\in [N] \land Nscore(i) > \max(Cscore)\}$
\STATE \qquad {\bf let} $X = X \setminus I$ 
\RETURN $X$.
% \ENSURE 
\end{algorithmic}
\end{algorithm}
%

\newpage
\bibliographystyle{plain}
\bibliography{verifysnap.bib}

\end{document}



