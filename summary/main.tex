\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\input{prelude}
\input{ldef}
\usepackage{eucal}
\usepackage{url}
\usepackage{tikz}
\usepackage{amsfonts,amsmath}
\usepackage{hyperref}
\begin{document}

\title{Verifying Differential Privacy in Floating-Point Computation}
\author{}

\date{}

\maketitle
\section{Introduction}
The programs of differentially private algorithms can be formally verified via existing logics and tools\cite{barthe2016proving}. 
However, these verifications are under the assumption that the implementations of these algorithms are over real computing without computation error.
While in reality, these algorithms are mostly implemented in floating-point computation with computation errors.
These computation errors can cause critical failure in preserving differential privacy, which is identified in several literatures \cite{balcer2017differential, gazeau2016preserving, mckenna2020permute, mironov2012significance}.
%

To verify the differential privacy property of
the algorithms implemented in floating-point computation such as snapping mechanism \cite{mironov2012significance},
we follow the logic rules designed from
\cite{barthe2016proving} and connecting 
it with the floating-point computation.

\section{Syntax}
\[\begin{array}{llll}
\mbox{Programs} & \prog & ::= & 
	%
     \varx = \expr ~|~ \varx \samplel \edistr
	%
	~|~ \prog ; \prog \\

\mbox{Expr} & \expr & ::= & \rval^{\mathbb{R}}
	%
	~|~ \varx  ~|~ \expr \bop \expr
	%
	~|~ \uop (\expr) \\
%
\mbox{Binary Operation} & \bop & ::= & + ~|~ - ~|~ \times ~|~ \div \\
%
\mbox{Unary Operation} & \uop & ::= & \ln ~|~ - ~|~ \round{\cdot} 
	%
	~|~ \clamp_B(\cdot) \\
%
\mbox{Value} & \valv & ::= & \fval^{\mathbb{F}}_{(\rval^{\mathbb{R}}, \rval^{\mathbb{R}})}\\
%
\mbox{Distr} & \edistr & ::= & \uniform(0, 1]
%
	~|~ \uniform\{-1, 1\}\\ 
%
\mbox{Error} & \err & ::= & {(\rval^{\mathbb{R}}, \rval^{\mathbb{R}})} \\
%
\mbox{Env} & \trsmem & ::= & \cdot ~|~ \trsmem[x \mapsto (\fval^{\mathbb{F}}_{(\rval^{\mathbb{R}}, \rval^{\mathbb{R}})})]\\
%
\mbox{Type} & \tau & ::= & \float ~|~ \real ~|~ \float_{\real \times \real}
\end{array}
\]
where $\rval$ is in domain of real number $\real$, $\rval \in \real$ and $\fval$ is in domain of floating point number $\float$, $\fval \in \float$. Furthermore, the domain of floating point number $\float$ is a subset of $\real$ containing the real number that can be represented in the floating point computation. The type $\float_{\real \times \real}$ represents the base type of expressions. In Env., the variables are mapped to $(\fval_{\err})$ of the type $\float_{\real \times \real}$.


%
\paragraph{Semantics.}
$\boxed{Env \times Expr \to Value }$
%
\[
	\begin{array}{rcl}
	\sem{\expr}_{\trsmem}
	& \in &  
	\big\{\fval_{(\rval_{l}, \rval_{u})} ~|~
	\trsmem,  
	\expr \trsto (\fvalv_{(\rval_{l}, \rval_{u})})\big\}
	\end{array}
\]
%
$
\boxed{Env \times \distr \to 
\distr(Value)}
$
%
\[
	\begin{array}{rcl}
	\sem{\uniform(0, 1]}_{\trsmem}
	& \in & 
	\big\{
	(\fval_{(\rval_{l}, \rval_{u})}) ~|~
	\fval \leftarrow \muniform(0, 1]
	\land \rval_{l} = \rval_{u} = \fval
	\big\}\\
	\sem{\uniform\{-1, 1\}}_{\trsmem}
	& \in & 
	\big\{
	(-1_{(-1, -1)}), (1_{(1, 1)}) ~|~
	each ~ w.p. ~ 0.5 
	\big\}\\	
	\end{array}
\]
%
$\boxed{Env \times prog \to \distr(Env)}$
\[
\begin{array}{rcl}
	%
	\sem{\varx \samplel \edistr}_{\trsmem}
	& = & 
	\elet \fval_{(\rval_{l}, \rval_{u})} = \sem{\edistr}_{\trsmem}
	\ein 
	\unit{\trsmem[\varx \mapsto \fval_{(\rval_{l}, \rval_{u})}]}
	\\
	%
	\sem{\varx = \expr}_{\trsmem}
	& = &  
	~\unit{\trsmem[\varx \mapsto \sem{\expr}_{\trsmem}]}
	\\
	%
	\sem{\prog_1; \prog_2}_{\trsmem}
	& = &  \elet  \trsmem_1 = 
	\sem{\prog_1}_{\trsmem} \ein
	\sem{\prog_2}_{\trsmem_1} 
\end{array}
\]
%
In the semantics, 
%
$\trsmem, \expr \trsto (\fvalv_{\err})$ represents given an environment
%
$\trsmem$, the expression $\expr$
%
is transited to $\fvalv$ with error bound $err = (\rval_{l}, \rval_{u})$
in floating point transition semantics,
%
s.t. $\rval_{l} \leq \fvalv \leq \rval_{u}$. The semantics is presented in Figure. \ref{fig_imp_trans_semantics_exp}.
%
$\trsmem, \prog \trsto \trsmem'$ represents given and environment $\trsmem$,
%
the program $\prog$ is transited to a new environment $\trsmem'$.
%
The $\muniform(0, 1] \in \distr(\float)$ is the mathematic uniform distribution over floating point values ranging over $(0, 1]$.
%
%
\begin{figure}
\boxed{\trsenv, \expr \trsto \fval^{\mathbb{F}}_{(\rval^{\mathbb{R}}, \rval^{\mathbb{R}})}
: Env \times Expr \trsto Value}
\begin{mathpar}
\inferrule*[right = var]
{
	\trsenv(\varx) 
	= (\fval, ( \ubar{\rval}, \bar{\rval} ))
}
{
	\trsenv, \varx
	\trsto
	(\fval, ( \ubar{\rval}, \bar{\rval} ))
}
\and
%
\inferrule*[right = val]
{
	\fval = \floaten(\rval)
	~~
	\fval \neq \rval
	\and
	\rval \geq 0
}
{
	\trsenv, \rval
	\trsto
	\big(\fval, 
	(\frac{\rval}{(1 + \eta)}, \rval(1 + \eta)) 
	\big)
}
%
\and
%
\inferrule*[right = val-neg]
{
	\fval = \floaten(\rval) 
	~~
	\fval \neq \rval
	\and
	\rval < 0
}
{
	\trsenv, \rval
	\trsto
	\big(\fval, (\rval(1 + \eta), \frac{\rval}{(1 + \eta)}) \big)
}
%
\and
%
\inferrule*[right = val-eq]
{
	\fval = \floaten(\rval)
	~~~~
	\fval = \rval
}
{
	\trsenv, \rval
	\trsto
	(\fval, (\rval, \rval) )
}
%
\and
%
\inferrule*[right = bop-pp]
{
	\trsenv, \expr_1 \trsto (\fval^1, (\ubar{\rval^1}, \bar{\rval^1}))
	~~~~
	\trsenv, \expr_2 \trsto (\fval^2, (\ubar{\rval^2}, \bar{\rval^2}))
	~~~~
	\fval^1 \geq 0
	~~~~
	\fval^2 \geq 0
	~~~~
	\fval = \floaten(\fval^1 * \fval^2)
	~~~~
	* \in \{\times, \div \}
}
{
    \trsenv, \expr_1 * \expr_2
    \trsto
    \big(
    \fval,
    (\frac{\ubar{\rval^1} * \ubar{\rval^2}}{(1 + \eta)}, 
        (\bar{\rval^1} * \bar{\rval^2})(1 + \eta))
    \big)
}
%
\and
%
\inferrule*[right = bop-nn]
{
	\trsenv, \expr_1 \trsto (\fval^1, (\ubar{\rval^1}, \bar{\rval^1}))
	~~~~
	\trsenv, \expr_2 \trsto (\fval^2, (\ubar{\rval^2}, \bar{\rval^2}))
	~~~~
	\fval^1 < 0
	~~~~
	\fval^2 < 0
	~~~~
	\fval = \floaten(\fval^1 * \fval^2)
	~~~~
	* \in \{\times, \div \}
}
{
    \trsenv, \expr_1 * \expr_2
    \trsto
    \big(
    \fval,
    (\frac{\bar{\rval^1} * \bar{\rval^2}}{(1 + \eta)}, 
        (\ubar{\rval^1} * \ubar{\rval^2})(1 + \eta))
    \big)
}
%
\and
%
\inferrule*[right = bop-pn]
{
	\trsenv, \expr_1 \trsto (\fval^1, (\ubar{\rval^1}, \bar{\rval^1}))
	~~~~
	\trsenv, \expr_2 \trsto (\fval^2, (\ubar{\rval^2}, \bar{\rval^2}))
	~~~~
	\fval^1 \geq 0
	~~~~
	\fval^2 < 0
	~~~~
	\fval = \floaten(\fval^1 * \fval^2)
	~~~~
	* \in \{\times, \div \}
}
{
    \trsenv, \expr_1 * \expr_2
    \trsto
    \big(
    \fval,
    ((\bar{\rval^1} * \ubar{\rval^2})(1 + \eta),
    \frac{\ubar{\rval^1} * \bar{\rval^2}}{(1 + \eta)})
    \big)
}
%
\and
%
\inferrule*[right = bop-np]
{
	\trsenv, \expr_1 \trsto (\fval^1, (\ubar{\rval^1}, \bar{\rval^1}))
	~~~~
	\trsenv, \expr_2 \trsto (\fval^2, (\ubar{\rval^2}, \bar{\rval^2}))
	~~~~
	\fval^1 < 0
	~~~~
	\fval^2 \geq 0
	~~~~
	\fval = \floaten(\fval^1 * \fval^2)
	~~~~
	* \in \{\times, \div \}
}
{
    \trsenv, \expr_1 * \expr_2
    \trsto
    \big(
    \fval,
    ((\ubar{\rval^1} * \bar{\rval^2})(1 + \eta),
    \frac{\bar{\rval^1} * \ubar{\rval^2}}{(1 + \eta)})
    \big)
}
%
\and
%
\inferrule*[right = bop-p]
{
	\trsenv, \expr_1 \trsto (\fval^1, (\ubar{\rval^1}, \bar{\rval^1}))
	~~~~
	\trsenv, \expr_2 \trsto (\fval^2, (\ubar{\rval^2}, \bar{\rval^2}))
	~~~~
	\fval = \floaten(\fval^1 * \fval^2)
	~~~~
	\fval \geq 0
	~~~~
	* \in \{+, - \}
}
{
    \trsenv, \expr_1 * \expr_2
    \trsto
    \big(
    \fval,
    (\frac{\ubar{\rval^1} * \ubar{\rval^2}}{(1 + \eta)}, 
        (\bar{\rval^1} * \bar{\rval^2})(1 + \eta))
    \big)
}
%
\and
%
\inferrule*[right = bop-n]
{
	\trsenv, \expr_1 \trsto (\fval^1, (\ubar{\rval^1}, \bar{\rval^1}))
	~~~~
	\trsenv, \expr_2 \trsto (\fval^2, (\ubar{\rval^2}, \bar{\rval^2}))
	~~~~
	\fval = \floaten(\fval^1 * \fval^2)
	~~~~
	\fval < 0
	~~~~
	* \in \{+, - \}
}
{
    \trsenv, \expr_1 * \expr_2
    \trsto
    \big(
    \fval,
    ((\ubar{\rval^1} * \ubar{\rval^2})(1 + \eta),
        \frac{\bar{\rval^1} * \bar{\rval^2}}{(1 + \eta)})
    \big)
}
%
\and
%
\inferrule*[right = uop-p]
{
	\trsenv, \expr \trsto (\fval', (\ubar{\rval}, \bar{\rval}))
	~~~~
	\fval = \floaten(\uop (\fval')) 
	~~~~
	\fval \geq 0
}
{
    \trsenv, \uop(\expr)
    \trsto
    \Big(\fval,
    \big(
    \frac{\uop(\ubar{\rval})}{(1 + \eta)}, 
    (\uop(\bar{\rval}))(1 + \eta)
    \big)
    \Big)
}
%
~~~~
%
\inferrule*[right = uop-n]
{
	\trsenv, \expr \trsto (\fval', (\ubar{\rval}, \bar{\rval}))
	~~~~
	\fval = \floaten(\uop (\fval')) 
	~~~~
	\fval < 0
}
{
    \trsenv, \uop(\expr)
    \trsto 
    \Big(\fval,
    \big(\uop(\ubar{\rval})(1 + \eta),
    \frac{\uop(\bar{\rval})}{(1 + \eta)}
    \big)
    \Big)
}
\end{mathpar}
\caption{Semantics of Transition for Expressions with Relative Floating Point Error}
\label{fig_imp_trans_semantics_exp}
\end{figure}
%
%
\section{Judgement and Validity}
%
\begin{defn}
[$\epsilon-$lifting \cite{barthe2016proving}]
Two sub-distributions $\mu_1 \in \distr(\mathcal{D}_1)$, $\mu_2 \in \distr(\mathcal{D}_2)$ are related by the $\epsilon-$lifting of $\Psi \subseteq \mathcal{D}_1 \times \mathcal{D}_2$, written $\mu_1 \Psi^{\#(\epsilon)} \mu_2$, if there exist two witness sub-distributions $\mu_L \in \distr(\mathcal{D}_1 \times \mathcal{D}_2)$ and $\mu_R \in \distr(\mathcal{D}_1 \times \mathcal{D}_2)$ s.t.:
\begin{enumerate}
	\item $\projl(\mu_L) = \mu_1$ and $\projr(\mu_R) = \mu_2$;
	\item $\supp(\mu_L) \subseteq \Psi$ and $\supp(\mu_R) \subseteq \Psi$; and
	\item $\Delta_{\epsilon}(\mu_L, \mu_R) \leq 0.0$.
\end{enumerate}
\end{defn}
%
%
\begin{defn}[$\Lambda$ equivalent]
Given two floating point values $\valv_1$ and $\valv_2$, if for some floating point value $\fvalv$ which is a multiple of $\Lambda$:
\[
	\fvalv - \frac{\Lambda}{2} \leq \valv_1 < \fvalv + \frac{\Lambda}{2}
	~~
	\land
	~~
	\fvalv - \frac{\Lambda}{2} \leq \valv_2 < \fvalv + \frac{\Lambda}{2},	
\]
then $\valv_1$ and $\valv_2$ are $\Lambda$ equivalent, i.e., 
$\valv_1 \lameq \valv_2 \lameq \fvalv$.
\end{defn}
%
%
\begin{defn}[tagged variable]
Let $\mathcal{X}\langle 1 \rangle$ and $\mathcal{X}\langle 2 \rangle$ be the sets of tagged variables, finite sets of variable names tagged with $\langle 1 \rangle$ or $\langle 2 \rangle$ respectively:
\[
	\mathcal{X}\langle 1 \rangle = \{\varx\langle 1 \rangle ~|~ x \in \mathcal{X}\}
	~~
	\text{and}
	~~
	\mathcal{X}\langle 2 \rangle = \{\varx\langle 2 \rangle ~|~ x \in \mathcal{X}\},
\]
where $\mathcal{X}$ is a finite set of variable names.
\end{defn}
%
\paragraph{Assertion.} We consider a set $\mathcal{A}$ of assertions (predicates) from first order logic by the following grammar:
\[
\begin{array}{llll}
%
%
\mbox{Logic Expr.} & \mathcal{E} & ::= & \mathcal{L}
	~|~ \mathcal{V}
 	~|~ \mathcal{E} + \mathcal{E}
%  \\
% & & &
 ~|~ \mathcal{E} - \mathcal{E}
 ~|~ \mathcal{E} \cdot \mathcal{E}
 ~|~ \ln(\mathcal{E}) ~|~ -\mathcal{E} ~|~ e^{\mathcal{E}}
	\\
%
\mbox{Assert.} & \mathcal{A} & ::= & 
\expr^{i} \langle 1 / 2 \rangle = \expr^i\langle 1 / 2 \rangle 
 ~|~ \expr^i\langle 1 / 2 \rangle < \expr^i\langle 1 / 2 \rangle) 
%  \\
% & & &
 ~|~ \expr^i\langle 1 / 2 \rangle \leq \expr^i\langle 1 / 2 \rangle
 ~|~ \expr^i\langle 1 / 2 \rangle \lameq \expr^i\langle 1 / 2 \rangle
	\\
 & & &
~|~  \mathcal{E} = \mathcal{E} ~|~ \cdots
~|~ \mathcal{E} =  \expr^{i} \langle 1 / 2 \rangle ~|~ \cdots
~|~ \expr^{i} \langle 1 / 2 \rangle =  \mathcal{E} ~|~ \cdots
	\\
 & & &
~|~  \top ~|~ \bot
	~|~ \mathcal{A} \land \mathcal{A} ~|~ \mathcal{A} \lor \mathcal{A} ~|~ \neg \mathcal{A}
	~|~ \mathcal{A} \imply \mathcal{A}
	~|~ \forall L \in \mathcal{D}. ~ \mathcal{A}
	~|~ \exists L \in \mathcal{D}. ~ \mathcal{A}
\end{array}
\]
%
We typically use capital Greek letters ($\Phi, \Psi, \cdots$) for predicates. 
%
$\expr\langle 1 / 2 \rangle$ denotes an expression where program variables are tagged with $\langle 1 \rangle$ or $\langle 2 \rangle$.
%
$\expr^i\langle 1 / 2 \rangle$ represents an expression where program variables are projected to the $i^{th}$ value from its triples, where $i \in \{1, 2, 3\}$. $\mathcal{D}$ is a specfic domain, it could be integers, $\real$, $\float$ or range of intergers, $\real$, $\float$, etc.
\\
The logic context are maps $\mathcal{L} \to \mathcal{V}$; usually written $\lmem$. The logic expression $\mathcal{E}$ is interpreted in a real computation way, such as:
%
$\sem{\mathcal{E}_1 + \mathcal{E}_2}_{\lmem} = \sem{\mathcal{E}_1}_{\lmem} + \sem{\mathcal{E}_2}_{\lmem}$, etc.
%
%
\paragraph{Assertion Interpretation.} Assertions are interpreted as relations between environments, i.e., set of paired environments. Let $\Phi$ be an assertion,
%
by the definition of $\mathcal{A}$, we have $\sem{\mathcal{A}}$ as:
\\
$\sem{\expr^i\langle 1 \rangle 
= \expr^i\langle 2 \rangle}_{\lmem} = 
\{(\trsmem_1, \trsmem_2) 
~|~ (\sem{\expr}_{\trsmem_{1}})^i 
= (\sem{\expr}_{\trsmem_2})^i \};
~ \cdots; 
%
~~~~
%
\sem{\mathcal{E}_1
= \mathcal{E}_2}_{\lmem} = 
\{(\trsmem_1, \trsmem_2) ~|~ \sem{\mathcal{E}_1}_{\lmem} 
< \sem{\mathcal{E}_2}_{\lmem} \};
~\cdots;
%
$
\\
$
%
\sem{\expr^i\langle 1 \rangle 
< \mathcal{E}}_{\lmem} = 
\{(\trsmem_1, \trsmem_2) ~|~ (\sem{\expr}_{\trsmem_{1}})^i 
< \sem{\mathcal{E}}_{\lmem} \};
~\cdots;
%
~~~~~~~~~~~~~~
\sem{\mathcal{E} 
\leq \expr^i\langle 2 \rangle}_{\lmem} = 
\{(\trsmem_1, \trsmem_2) ~|~ \sem{\mathcal{E}}_{\lmem}
\leq (\sem{\expr}_{\trsmem_2})^i \};
%
~\cdots;$
%
\\
$
\sem{\mathcal{A}_1 \land \mathcal{A}_2}_{\lmem} = \big\{(\trsmem_1, \trsmem_2)
~|~ (\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}_1}_{\lmem} \land 
	(\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}_2}_{\lmem} \big\};
~~~~~~~
\sem{\top}_{\lmem} = \{(\trsmem_1, \trsmem_2)\};
~~~~~~~~~~
\sem{\bot}_{\lmem}  = \{\};
$
%
\\
$\sem{\mathcal{A}_1 \lor \mathcal{A}_2}_{\lmem} = \big\{(\trsmem_1, \trsmem_2)
~|~ (\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}_1}_{\lmem} \lor 
	(\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}_2}_{\lmem} \big\};
	~~~~~~~
\sem{\neg \mathcal{A}}_{\lmem} = \big\{(\trsmem_1, \trsmem_2)
~|~ (\trsmem_1, \trsmem_2) \notin \sem{\mathcal{A}}_{\lmem} \big\};$
%
\\
$\sem{\mathcal{A}_1 \imply \mathcal{A}_2}_{\lmem} = \big\{(\trsmem_1, \trsmem_2)
~|~ (\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}_1}_{\lmem} \imply 
	(\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}_2}_{\lmem} \big\};$
%
\\
$\sem{\forall L \in \mathcal{D}. ~\mathcal{A}}_{\lmem} = \big\{(\trsmem_1, \trsmem_2)
~|~ \forall v \in \mathcal{D}. ~ (\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}}_{\lmem[L \to v]} \big\};$
%
\\
$\sem{\exists L \in \mathcal{D}. ~\mathcal{A}}_{\lmem} = \big\{(\trsmem_1, \trsmem_2)
~|~ \exists v \in \mathcal{D}. ~ (\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}}_{\lmem[L \to v]} \big\}.$
%
%
%
\paragraph{Judgment.}
The judgments are defined in following form:
\[
	\prog_1 \sim_{\epsilon} \prog_2: \Phi \Rightarrow \Psi.
\]
Here, $\prog_1$ and $\prog_2$ are programs and $\Phi$ and $\Psi$ are assertions on pairs of memories. Each assertions can refer to two copies $x\langle 1 \rangle, x\langle 2 \rangle$ of each program variable $x$, where these tagged variables refer to the value of x in the execution of $\prog_1$ and $\prog_2$ respectively.
%
\\
A judgment is valid, written $\vdash \prog_1 \sim_{\epsilon} \prog_2: \Phi_0 \Rightarrow \Phi$, 
if for any two environments $\trsmem_1$ and $\trsmem_2$ satisfying precondition $\Phi_0$, 
i.e., $(\trsmem_1, \trsmem_2) \in \sem{\Phi_0}$, there exists a lifting of $\Phi$ relating the output distributions: 
%
$(\sem{\prog_1}_{\trsmem_1})$ 
$\sem{\Phi}^{\#(\epsilon)}$ 
$(\sem{\prog_2}_{\trsmem_2})$.
%
\\
%
Fig. \ref{fig:aprhl} presents the main rules from apRHL+ \cite{barthe2016proving} excluding the while and condition rules which is not defined in out syntax, as well as the sampling rule, which we generalized in extended apRHL.
The rule in Fig. \ref{fig:aprhlplus} represents the lifting proved in soundness theorem.
%
\begin{figure}[ht]
\boxed{\vdash: prog \times prog \times \real \times Assert \times Assert}
{\small
\begin{mathpar}
\inferrule
{
	\empty
}
{
	\vdash
	\varx \samplel \uniform(0, 1] 	
	\sim_{\epsilon} 
	\vary \samplel \uniform(0, 1]
	:
	\top
	\Rightarrow
	\forall \rvalL, \rvalR \in [0,1]^{\real}. ~
	\rvalL \leq \varx^1 \langle 1 \rangle \leq \rvalR 
	\imply
	(e^{\epsilon} \rvalL \leq \vary^1 \langle 2 \rangle \leq e^{\epsilon}\rvalR \land \vary^1 \langle 2 \rangle \leq 1)	
}
~\textbf{Unif+}
\and
\inferrule
{
	\empty
}
{
	\vdash
	\varx \samplel \uniform(0, 1] 	
	\sim_{\epsilon} 
	\vary \samplel \uniform(0, 1]
	:
	\top
	\Rightarrow
	\forall \rvalL, \rvalR \in [0,1]^{\real}.
	(\rvalL \leq \varx^1 \langle 1 \rangle \leq \rvalR 
	 		\imply
	 		e^{-\epsilon} \rvalL \leq \vary^1 \langle 2 \rangle \leq e^{-\epsilon}\rvalR) 	
}
~\textbf{Unif-}
\and
%
\inferrule
{
\empty
}
{
	\vdash 
	\varx_1 \samplel \edistr
	\sim_{0} 
	\varx_2 \samplel \edistr
	: \top \Rightarrow 
	(\varx_2^1\langle 2 \rangle) 
	= (\varx_1^1\langle 1 \rangle )
	\land (\varx_2^2\langle 2 \rangle) = (\varx_1^2\langle 1 \rangle)
	\land (\varx_2^3\langle 2 \rangle) = (\varx_1^3\langle 1 \rangle)
}~\textbf{Null}
\and
\inferrule
{
\forall \valv. \text{ a multiple of } \Lambda
}
{
	\vdash 
	\varx_1 = \round{\vary_1}_{\Lambda}	
	\sim_{0} 
	\varx_2 = \round{\vary_2}_{\Lambda}
	: \vary_1^1 \langle 1 \rangle \lameq \valv
	\imply
	\vary_2^1 \langle 2 \rangle \lameq \valv
	\Rightarrow 
	(\varx^1_1 \langle 1 \rangle = \valv) 
	\imply (\varx^1_2 \langle 2 \rangle = \valv)
}~\textbf{Round}
\end{mathpar}
}
\caption{Rules Extended from apRHL+}
\label{fig:aprhlplus}
\end{figure}
%
\begin{figure}[ht]
\begin{mathpar}
\inferrule
{
\empty
}
{
	\vdash 
	\varx_1 = \expr_1  
	\sim_{0} 
	\varx_2 = \expr_2  
	: \Phi[\expr_1/\varx_1\langle 1 \rangle]
	[\expr_2/\varx_2\langle 2 \rangle]  \Rightarrow \Phi
}~\textbf{Assn}
~~~
\inferrule
{
\prog_1 \sim_{\epsilon} \prog_2 : \Phi_1 \Rightarrow \Phi'_1
\\
\prog'_1 \sim_{\epsilon'} \prog'_2 : \Phi'_1 \Rightarrow \Phi_2
}
{
	\vdash 
	\prog_1; \prog'_1  
	\sim_{\epsilon + \epsilon'} 
	\prog_2; \prog'_2
	: \Phi_1  \Rightarrow  \Phi_2
}~\textbf{Seq}
\and
\inferrule
{
\prog_1 \sim_{\epsilon} \prog_2 : \Phi'_1 \Rightarrow \Phi'_2
\and
\Phi_1 \Rightarrow \Phi'_1
\and 
\Phi'_2 \Rightarrow \Phi_2
\and 
\epsilon \leq \epsilon'
}
{
\prog_1 \sim_{\epsilon'} \prog_2 : 
\Phi_1 \Rightarrow \Phi_2
}~\textbf{Conseq}
\end{mathpar}
\caption{Proving Rules from apRHL}
\label{fig:aprhl}
\end{figure}
%
%
\begin{lem}[Discrete Support of Distribution]
 $\forall \prog, \trsmem, \edistr$,  s.t. $\edistr \in \distr(Env)$ and $\sem{\prog}_{\trsmem} = \edistr$. Then $\supp{(\edistr)}$ is discrete.
\end{lem}
%
\begin{proof}
By induction on $\prog$, we have the proof of this Lemma in detailed versions.
\end{proof}
%
%
\begin{thm}[Soundness]
 $\forall \prog_1$, $\prog_2$,  $ \vdash \prog_1	
\sim_{\epsilon} 
\prog_2 :
\Phi_0 \Rightarrow \Phi $,    $\forall \trsmem_1$, $\trsmem_2$ 
s.t $\Phi_0$: 
$\trsmem_1 ~ \sem{\Phi_0} ~ \trsmem_2$,
then
$$ 
(\sem{\prog_1}_{\trsmem_1})  
\sem{\Phi}^{\#(\epsilon)} 
(\sem{\prog_2}_{\trsmem_2}) 
$$.
\end{thm}
%
%
%
\begin{proof}
By induction on the judgment $\vdash \prog_1	
\sim_{\epsilon}
\prog_2 :
\Phi_0 \Rightarrow \Phi $,  we have the proof of this Lemma in detailed versions.
\end{proof}
%
%
\begin{thm}
\label{thm:unif+_coupling}
%
$${\muniform(0,1]} ~ R^{\#(\epsilon)} ~ {\muniform(0,1]},$$
%
where
	$	R = 
		\left \{(\varx, \vary) \in {\float} \times {\float} 
		~|~
		\forall \rvalL, \rvalR \in [0,1]^{\real}. ~
		\rvalL \leq \varx \leq \rvalR
		\imply
		(e^{\epsilon} \rvalL \leq \vary \leq 	e^{\epsilon} \rvalR
		\land \vary \leq 1)
		\right \}
		$.
	%
\end{thm}
%
\begin{proof}[Proof of Theorem \ref{thm:unif+_coupling} seen in full version]
%
\end{proof}
%
%
\begin{thm}
\label{thm:unif-_coupling}
$${\muniform(0,1]} ~ R^{\#(\epsilon)} ~ {\muniform(0,1]},$$
%
where
	$R = 
		\left \{(\fval_1, \fval_2) \in {\float} \times {\float} 
		~|~
		\forall \rvalL, \rvalR \in (0,1]^{\real}.
		(\rvalL \leq \fval_1 \leq \rvalR
				\imply
				e^{-\epsilon} \rvalL \leq \fval_2 \leq 	e^{-\epsilon} \rvalR)
		\right \}	
		$.
	%
\end{thm}
%
\begin{proof}[Proof of Theorem \ref{thm:unif-_coupling} seen in full version]
%
\end{proof}
%
%
%
%
\newpage
\section{Examples}

\begin{defn}
[Snapping Mechanism: $\snap(a) : A \to \distr(\real)$]
Given privacy parameter $\epsilon$, the Snapping mechanism $\snap(a)$ is defined as:
\[
	\varu \samplel \uniform(0,1); s \samplel \uniform\{-1, 1\};
	\varx = f(a) + \frac{1}{\epsilon} \times s \times \ln (\varu);
	\vary = \round{\varx}_{\Lambda};
	\varz = \clamp_B (\vary)
\]
where $f(a)$ represents a value that the query function $f$ be evaluated over input database $a \in A$, $\epsilon$ is the privacy parameter, $B$ is the clamping argument and $\Lambda$ is the rounding argument satisfying $\lambda = 2^k$ where $2^k$ is the smallest power of 2 greater or equal to the $\frac{1}{\epsilon}$.
\end{defn}
%
\begin{thm}[The $\snap$ mechanism is 
$\epsilon-$differentially private]
\end{thm}
\begin{proof}[seen in full version]
\end{proof}

\newpage
\bibliographystyle{plain}
\bibliography{verifysnap.bib}

\end{document}



