\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\input{prelude}
\input{ldef}
\usepackage{eucal}
\usepackage{url}
\usepackage{tikz}
\usepackage{amsfonts,amsmath}
\usepackage{hyperref}
\begin{document}

\title{Verifying Differential Privacy in Floating-Point Computation}
\author{}

\date{}
\maketitle
\begin{abstract}
The programs implementing differentially private algorithms can be formally verified via existing logics and tools, such as $\mathsf{apRHL}^+$\cite{barthe2016proving}. 
These verifications rely on the assumption that these implementations whose underlining computation is real number based without computation error.
However, in reality, these algorithms are mostly implemented under finite precision, which accounts for computation errors
and cause critical failures in preserving differential privacy. 

We develop a method for formally verifying differential privacy of algorithms implemented based on floating-point computation. Our method extends the relational program logic $\mathsf{apRHL}^+$, and provides an operational semantics over floating-point computation, which work together to provide the formal verification.

We demonstrate our method on an algorithm: the \emph{Snapping mechanism}, which proposed in \cite{mironov2012significance}, where its differential privacy is theoretically proved that even in floating-point computation.
We implement our logic and example verifications in Coq.
\end{abstract}

\section{Introduction}
Differential privacy proposed by Dwork, McSherry, Nissim, and Smith \cite{dwork2006calibrating} is considered the gold standard for privacy-preserving computations. 
%
Existing methods are able to formally verify the differential privacy of most of the popular algorithms \cite{barthe2016proving}. 
However, these verifications are based on the ideal implementations of these algorithms without computation error.
While in reality, the implementations of these algorithms are not ideal, mostly in floating-point computation with computation errors.
These computation errors can cause critical failures in preserving differential privacy, which is identified in the literature \cite{balcer2017differential, gazeau2016preserving, mckenna2020permute, mironov2012significance, ilvento2020implementing}.
%
In the meantime, some algorithms claim to preserve differential privacy even in floating-point computation, for instance:
\begin{itemize}
	\item The \emph{Snapping mechanism}, which is an improved version of the implementation of Laplace mechanism in floating-point computation, by adding extra rounding and clamping operations. (See \cite{mironov2012significance}.)
%
	\item The \emph{Base-2 Exponential mechanism}, which is a revised version of the Exponential mechanism, by altering the base in Exponential mechanism from $e$ into $2$. (See \cite{ilvento2020implementing}.)
%
	\item The \emph{Discrete Gaussian mechanism}, which is a discrete version of the Gaussian mechanism. (See \cite{canonne2020discrete}.)
\end{itemize}
%
Unfortunately, existing pen-and-paper proofs of these algorithms use complex computation error approximations, which are hard to understand and error-prone.

This gives us the motivation that can we develop methods for formally and automatically verifying these algorithms by considering the errors that arose during the floating-point computation.

To verify the differential privacy property of
the algorithms implemented in floating-point computation,
we firstly extend the relational program logic $\mathsf{apRHL}^+$ from
\cite{barthe2016proving}. 
Then we compose 
it with an operational semantics designed for approximating the floating-point computation error.
%
We prove the soundness via the methodology of probabilistic coupling and approximate lifting shown by Barth et al. \cite{barthe2016proving}.
%
\section{Syntax}
The language is defined as follows.
\\
In the language, $\rval$ is in the domain of real number $\real$, $\rval \in \real$. 
$\fval$ is in the domain of floating point number $\float$, $\fval \in \float$. 
Furthermore, $\float$ is a subset of $\real$ allowing the $\fval$ be represented in $\real$ without lose of precision. 
On the other hand, $\rval$ sacrifices its precision when casted into $\float$.
The type $\float_{\real \times \real}$ represents the base type of values, composed of a floating-point value $\fval$ and a pair of real-number values $\rval$.
In environment., the variables are mapped to $(\fval_{(\rval, \rval)})$ of the type $\float_{\real \times \real}$.
%
\[\begin{array}{llll}
\mbox{Programs} & \prog & ::= & 
	%
     \varx = \expr ~|~ \varx \samplel \edistr
	%
	~|~ \prog ; \prog \\

\mbox{Expr} & \expr & ::= & \rval
	%
	~|~ \varx  ~|~ \expr \bop \expr
	%
	~|~ \uop (\expr) \\
%
\mbox{Binary Operation} & \bop & ::= & + ~|~ - ~|~ \times ~|~ \div \\
%
\mbox{Unary Operation} & \uop & ::= & \ln ~|~ - ~|~ \round{\cdot} 
	%
	~|~ \clamp_B(\cdot) \\
%
\mbox{Value} & \valv & ::= & \fval_{(\rval, \rval)}\\
%
\mbox{Distr} & \edistr & ::= & \uniform(0, 1]
%
	~|~ \uniform\{-1, 1\}\\ 
%
\mbox{Error} & \err & ::= & (\rval, \rval) \\
%
\mbox{Env} & \trsmem & ::= & \cdot ~|~ \trsmem[x \mapsto (\fval_{(\rval, \rval)})]\\
%
\mbox{Type} & \tau & ::= & \float ~|~ \real ~|~ \float_{\real \times \real}
\end{array}
\]


%
\paragraph{Semantics.} The denotational semantics are defined as follows.
\\
$\boxed{Env \times Expr \to Value }$
%
\[
	\begin{array}{rcl}
	\sem{\expr}_{\trsmem}
	& \in &  
	\big\{\fval_{(\rval_{l}, \rval_{u})} ~|~
	\trsmem,  
	\expr \trsto (\fvalv_{(\rval_{l}, \rval_{u})})\big\}
	\end{array}
\]
%
$
\boxed{Env \times \distr \to 
\distr(Value)}
$
%
\[
	\begin{array}{rcl}
	\sem{\uniform(0, 1]}_{\trsmem}
	& \in & 
	\big\{
	(\fval_{(\rval_{l}, \rval_{u})}) ~|~
	\fval \leftarrow \muniform(0, 1]
	\land \rval_{l} = \rval_{u} = \fval
	\big\}\\
	\sem{\uniform\{-1, 1\}}_{\trsmem}
	& \in & 
	\big\{
	(-1_{(-1, -1)}), (1_{(1, 1)}) ~|~
	each ~ w.p. ~ 0.5 
	\big\}\\	
	\end{array}
\]
%
$\boxed{Env \times prog \to \distr(Env)}$
\[
\begin{array}{rcl}
	%
	\sem{\varx \samplel \edistr}_{\trsmem}
	& = & 
	\elet \fval_{(\rval_{l}, \rval_{u})} = \sem{\edistr}_{\trsmem}
	\ein 
	\unit{\trsmem[\varx \mapsto \fval_{(\rval_{l}, \rval_{u})}]}
	\\
	%
	\sem{\varx = \expr}_{\trsmem}
	& = &  
	~\unit{\trsmem[\varx \mapsto \sem{\expr}_{\trsmem}]}
	\\
	%
	\sem{\prog_1; \prog_2}_{\trsmem}
	& = &  \elet  \trsmem_1 = 
	\sem{\prog_1}_{\trsmem} \ein
	\sem{\prog_2}_{\trsmem_1} 
\end{array}
\]
%
In the semantics, 
%
$\trsmem, \expr \trsto (\fvalv_{\err})$ reads given an environment
%
$\trsmem$, the expression $\expr$
%
is transited to $\fvalv$ with error bound $err = (\rval_{l}, \rval_{u})$
in floating point transition semantics,
%
s.t. $\rval_{l} \leq \fvalv \leq \rval_{u}$. The semantics is presented in Figure. \ref{fig_imp_trans_semantics_exp}.
%
$\trsmem, \prog \trsto \trsmem'$ represents, given an environment $\trsmem$,
%
the program $\prog$ is transited to a new environment $\trsmem'$.
%
The $\muniform(0, 1] \in \distr(\float)$ is the mathematic uniform distribution over floating point values ranging over $(0, 1]$.
%
%
\begin{figure}
\boxed{\trsenv, \expr \trsto \fval_{(\rval, \rval)}
: Env \times Expr \trsto Value}
\begin{mathpar}
\inferrule*[right = var]
{
	\trsenv(\varx) 
	= (\fval_{( \ubar{\rval}, \bar{\rval} )})
}
{
	\trsenv, \varx
	\trsto
	(\fval_{( \ubar{\rval}, \bar{\rval} )})
}
\and
%
\inferrule*[right = val]
{
	\fval = \floaten(\rval)
	~~
	\fval \neq \rval
	\and
	\rval \geq 0
}
{
	\trsenv, \rval
	\trsto
	\big(\fval_{(\frac{\rval}{(1 + \eta)}, \rval(1 + \eta))} 
	\big)
}
%
\and
%
\inferrule*[right = val-neg]
{
	\fval = \floaten(\rval) 
	~~
	\fval \neq \rval
	\and
	\rval < 0
}
{
	\trsenv, \rval
	\trsto
	\big(\fval_{(\rval(1 + \eta), \frac{\rval}{(1 + \eta)})} \big)
}
%
\and
%
\inferrule*[right = val-eq]
{
	\fval = \floaten(\rval)
	~~~~
	\fval = \rval
}
{
	\trsenv, \rval
	\trsto
	(\fval_{(\rval, \rval)} )
}
%
\and
%
\inferrule*[right = bop-pp]
{
	\trsenv, \expr_1 \trsto 
	(\fval_{1(\ubar{\rval_1}, \bar{\rval_1})})
	~~~~
	\trsenv, \expr_2 \trsto (\fval_{2(\ubar{\rval_2}, \bar{\rval_2})})
	~~~~
	\fval_1 \geq 0
	~~~~
	\fval_2 \geq 0
	~~~~
	\fval = \floaten(\fval_1 * \fval_2)
	~~~~
	* \in \{\times, \div \}
}
{
    \trsenv, \expr_1 * \expr_2
    \trsto
    \big(
    \fval_{(\frac{\ubar{\rval_1} * \ubar{\rval_2}}{(1 + \eta)}, 
        (\bar{\rval_1} * \bar{\rval_2})(1 + \eta))}
    \big)
}
%
\and
%
\inferrule*[right = bop-nn]
{
	\trsenv, \expr_1 \trsto (\fval_{1(\ubar{\rval_1}, \bar{\rval_1})})
	~~~~
	\trsenv, \expr_2 \trsto (\fval_{2(\ubar{\rval_2}, \bar{\rval_2})})
	~~~~
	\fval_1 < 0
	~~~~
	\fval_2 < 0
	~~~~
	\fval = \floaten(\fval_1 * \fval_2)
	~~~~
	* \in \{\times, \div \}
}
{
    \trsenv, \expr_1 * \expr_2
    \trsto
    \big(
    \fval_
    {(\frac{\bar{\rval_1} * \bar{\rval_2}}{(1 + \eta)}, 
        (\ubar{\rval_1} * \ubar{\rval_2})(1 + \eta))}
    \big)
}
%
\and
%
\inferrule*[right = bop-pn]
{
	\trsenv, \expr_1 \trsto (\fval_{1(\ubar{\rval_1}, \bar{\rval_1})})
	~~~~
	\trsenv, \expr_2 \trsto (\fval_{2(\ubar{\rval_2}, \bar{\rval_2})})
	~~~~
	\fval_1 \geq 0
	~~~~
	\fval_2 < 0
	~~~~
	\fval = \floaten(\fval_1 * \fval_2)
	~~~~
	* \in \{\times, \div \}
}
{
    \trsenv, \expr_1 * \expr_2
    \trsto
    \big(
    \fval_
    {((\bar{\rval_1} * \ubar{\rval_2})(1 + \eta),
        \frac{\ubar{\rval_1} * \bar{\rval_2}}{(1 + \eta)})}
    \big)
}
%
\and
%
\inferrule*[right = bop-np]
{
	\trsenv, \expr_1 \trsto (\fval_{1(\ubar{\rval_1}, \bar{\rval_1})})
	~~~~
	\trsenv, \expr_2 \trsto (\fval_{2(\ubar{\rval_2}, \bar{\rval_2})})
	~~~~
	\fval_1 < 0
	~~~~
	\fval_2 \geq 0
	~~~~
	\fval = \floaten(\fval_1 * \fval_2)
	~~~~
	* \in \{\times, \div \}
}
{
    \trsenv, \expr_1 * \expr_2
    \trsto
    \big(
    \fval_
    {((\ubar{\rval_1} * \bar{\rval_2})(1 + \eta),
        \frac{\bar{\rval_1} * \ubar{\rval_2}}{(1 + \eta)})}
    \big)
}
%
\and
%
\inferrule*[right = bop-p]
{
	\trsenv, \expr_1 \trsto (\fval_{1(\ubar{\rval_1}, \bar{\rval_1})})
	~~~~
	\trsenv, \expr_2 \trsto (\fval_{2(\ubar{\rval_2}, \bar{\rval_2})})
	~~~~
	\fval = \floaten(\fval_1 * \fval_2)
	~~~~
	\fval \geq 0
	~~~~
	* \in \{+, - \}
}
{
    \trsenv, \expr_1 * \expr_2
    \trsto
    \big(
    \fval_
    {(\frac{\ubar{\rval_1} * \ubar{\rval_2}}{(1 + \eta)}, 
            (\bar{\rval_1} * \bar{\rval_2})(1 + \eta))}
    \big)
}
%
\and
%
\inferrule*[right = bop-n]
{
	\trsenv, \expr_1 \trsto (\fval_{1(\ubar{\rval_1}, \bar{\rval_1})})
	~~~~
	\trsenv, \expr_2 \trsto (\fval_{2(\ubar{\rval_2}, \bar{\rval_2})})
	~~~~
	\fval = \floaten(\fval_1 * \fval_2)
	~~~~
	\fval < 0
	~~~~
	* \in \{+, - \}
}
{
    \trsenv, \expr_1 * \expr_2
    \trsto
    \big(
    \fval_
    {((\ubar{\rval_1} * \ubar{\rval_2})(1 + \eta),
            \frac{\bar{\rval_1} * \bar{\rval_2}}{(1 + \eta)})}
    \big)
}
%
\and
%
\inferrule*[right = uop-p]
{
	\trsenv, \expr \trsto (\fval_{1(\ubar{\rval}, \bar{\rval})})
	~~~~
	\fval = \floaten(\uop (\fval_1)) 
	~~~~
	\fval \geq 0
}
{
    \trsenv, \uop(\expr)
    \trsto
    \Big(\fval_
    {\big(
        \frac{\uop(\ubar{\rval})}{(1 + \eta)}, 
        (\uop(\bar{\rval}))(1 + \eta)
        \big)}
    \Big)
}
%
~~~~
%
\inferrule*[right = uop-n]
{
	\trsenv, \expr \trsto (\fval_{1(\ubar{\rval}, \bar{\rval})})
	~~~~
	\fval = \floaten(\uop (\fval_1)) 
	~~~~
	\fval < 0
}
{
    \trsenv, \uop(\expr)
    \trsto 
    \Big(\fval_
    {\big(\uop(\ubar{\rval})(1 + \eta),
        \frac{\uop(\bar{\rval})}{(1 + \eta)}
        \big)}
    \Big)
}
\end{mathpar}
\caption{Semantics of Transition for Expressions with Relative Floating Point Error}
\label{fig_imp_trans_semantics_exp}
\end{figure}
%
%
\section{Judgement and Validity}
%
\begin{defn}
[$\epsilon-$lifting \cite{barthe2016proving}]
Two sub-distributions $\mu_1 \in \distr(\mathcal{D}_1)$, $\mu_2 \in \distr(\mathcal{D}_2)$ are related by the $\epsilon-$lifting of $\Psi \subseteq \mathcal{D}_1 \times \mathcal{D}_2$, written $\mu_1 \Psi^{\#(\epsilon)} \mu_2$, if there exist two witness sub-distributions $\mu_L \in \distr(\mathcal{D}_1 \times \mathcal{D}_2)$ and $\mu_R \in \distr(\mathcal{D}_1 \times \mathcal{D}_2)$ s.t.:
\begin{enumerate}
	\item $\projl(\mu_L) = \mu_1$ and $\projr(\mu_R) = \mu_2$;
	\item $\supp(\mu_L) \subseteq \Psi$ and $\supp(\mu_R) \subseteq \Psi$; and
	\item $\Delta_{\epsilon}(\mu_L, \mu_R) \leq 0.0$.
\end{enumerate}
\end{defn}
%
%
\begin{defn}[$\Lambda$ equivalent]
Given two floating point values $\valv_1$ and $\valv_2$, if for some floating point value $\fvalv$ which is a multiple of $\Lambda$:
\[
	\fvalv - \frac{\Lambda}{2} \leq \valv_1 < \fvalv + \frac{\Lambda}{2}
	~~
	\land
	~~
	\fvalv - \frac{\Lambda}{2} \leq \valv_2 < \fvalv + \frac{\Lambda}{2},	
\]
then $\valv_1$ and $\valv_2$ are $\Lambda$ equivalent, i.e., 
$\valv_1 \lameq \valv_2 \lameq \fvalv$.
\end{defn}
%
%
\begin{defn}[tagged variable]
Let $\mathcal{X}\langle 1 \rangle$ and $\mathcal{X}\langle 2 \rangle$ be the sets of tagged variables, finite sets of variable names tagged with $\langle 1 \rangle$ or $\langle 2 \rangle$ respectively:
\[
	\mathcal{X}\langle 1 \rangle = \{\varx\langle 1 \rangle ~|~ x \in \mathcal{X}\}
	~~
	\text{and}
	~~
	\mathcal{X}\langle 2 \rangle = \{\varx\langle 2 \rangle ~|~ x \in \mathcal{X}\},
\]
where $\mathcal{X}$ is a finite set of variable names.
\end{defn}
%
\paragraph{Assertion.} We consider a set $\mathcal{A}$ of assertions (predicates) from first order logic by the following grammar:
\[
\begin{array}{llll}
%
%
\mbox{Logic Expr.} & \mathcal{E} & ::= & \mathcal{L}
	~|~ \mathcal{V}
 	~|~ \mathcal{E} + \mathcal{E}
%  \\
% & & &
 ~|~ \mathcal{E} - \mathcal{E}
 ~|~ \mathcal{E} \cdot \mathcal{E}
 ~|~ \ln(\mathcal{E}) ~|~ -\mathcal{E} ~|~ e^{\mathcal{E}}
	\\
%
\mbox{Assert.} & \mathcal{A} & ::= & 
\expr^{i} \langle 1 / 2 \rangle = \expr^i\langle 1 / 2 \rangle 
 ~|~ \expr^i\langle 1 / 2 \rangle < \expr^i\langle 1 / 2 \rangle) 
%  \\
% & & &
 ~|~ \expr^i\langle 1 / 2 \rangle \leq \expr^i\langle 1 / 2 \rangle
 ~|~ \expr^i\langle 1 / 2 \rangle \lameq \expr^i\langle 1 / 2 \rangle
	\\
 & & &
~|~  \mathcal{E} = \mathcal{E} ~|~ \cdots
~|~ \mathcal{E} =  \expr^{i} \langle 1 / 2 \rangle ~|~ \cdots
~|~ \expr^{i} \langle 1 / 2 \rangle =  \mathcal{E} ~|~ \cdots
	\\
 & & &
~|~  \top ~|~ \bot
	~|~ \mathcal{A} \land \mathcal{A} ~|~ \mathcal{A} \lor \mathcal{A} ~|~ \neg \mathcal{A}
	~|~ \mathcal{A} \imply \mathcal{A}
	~|~ \forall L \in \mathcal{D}. ~ \mathcal{A}
	~|~ \exists L \in \mathcal{D}. ~ \mathcal{A}
\end{array}
\]
%
We typically use capital Greek letters ($\Phi, \Psi, \cdots$) for predicates. 
%
$\expr\langle 1 / 2 \rangle$ denotes an expression where program variables are tagged with $\langle 1 \rangle$ or $\langle 2 \rangle$.
%
$\expr^i\langle 1 / 2 \rangle$ represents an expression where program variables are projected to the $i^{th}$ value from its triples, where $i \in \{1, 2, 3\}$. $\mathcal{D}$ is a specfic domain, it could be integers, reals, floating-point numbers or range of them, etc.
\\
The logic context are maps $\mathcal{L} \to \mathcal{V}$; usually written $\lmem$. The logic expression $\mathcal{E}$ is interpreted under real number computation, such as:
%
$\sem{\mathcal{E}_1 + \mathcal{E}_2}_{\lmem} = \sem{\mathcal{E}_1}_{\lmem} + \sem{\mathcal{E}_2}_{\lmem}$, etc.
%
%
\paragraph{Assertion Interpretation.} Assertions are interpreted as relations between environments, i.e., set of paired environments. Let $\Phi$ be an assertion,
%
by the definition of $\mathcal{A}$, we have $\sem{\mathcal{A}}$ as:
\\
$\sem{\expr^i\langle 1 \rangle 
= \expr^i\langle 2 \rangle}_{\lmem} = 
\{(\trsmem_1, \trsmem_2) 
~|~ (\sem{\expr}_{\trsmem_{1}})^i 
= (\sem{\expr}_{\trsmem_2})^i \};
~ \cdots; 
%
~~~~
%
\sem{\mathcal{E}_1
= \mathcal{E}_2}_{\lmem} = 
\{(\trsmem_1, \trsmem_2) ~|~ \sem{\mathcal{E}_1}_{\lmem} 
< \sem{\mathcal{E}_2}_{\lmem} \};
~\cdots;
%
$
\\
$
%
\sem{\expr^i\langle 1 \rangle 
< \mathcal{E}}_{\lmem} = 
\{(\trsmem_1, \trsmem_2) ~|~ (\sem{\expr}_{\trsmem_{1}})^i 
< \sem{\mathcal{E}}_{\lmem} \};
~\cdots;
%
~~~~~~~~~~~~~~
\sem{\mathcal{E} 
\leq \expr^i\langle 2 \rangle}_{\lmem} = 
\{(\trsmem_1, \trsmem_2) ~|~ \sem{\mathcal{E}}_{\lmem}
\leq (\sem{\expr}_{\trsmem_2})^i \};
%
~\cdots;$
%
\\
$
\sem{\mathcal{A}_1 \land \mathcal{A}_2}_{\lmem} = \big\{(\trsmem_1, \trsmem_2)
~|~ (\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}_1}_{\lmem} \land 
	(\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}_2}_{\lmem} \big\};
~~~~~~~
\sem{\top}_{\lmem} = \{(\trsmem_1, \trsmem_2)\};
~~~~~~~~~~
\sem{\bot}_{\lmem}  = \{\};
$
%
\\
$\sem{\mathcal{A}_1 \lor \mathcal{A}_2}_{\lmem} = \big\{(\trsmem_1, \trsmem_2)
~|~ (\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}_1}_{\lmem} \lor 
	(\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}_2}_{\lmem} \big\};
	~~~~~~~
\sem{\neg \mathcal{A}}_{\lmem} = \big\{(\trsmem_1, \trsmem_2)
~|~ (\trsmem_1, \trsmem_2) \notin \sem{\mathcal{A}}_{\lmem} \big\};$
%
\\
$\sem{\mathcal{A}_1 \imply \mathcal{A}_2}_{\lmem} = \big\{(\trsmem_1, \trsmem_2)
~|~ (\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}_1}_{\lmem} \imply 
	(\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}_2}_{\lmem} \big\};$
%
\\
$\sem{\forall L \in \mathcal{D}. ~\mathcal{A}}_{\lmem} = \big\{(\trsmem_1, \trsmem_2)
~|~ \forall v \in \mathcal{D}. ~ (\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}}_{\lmem[L \to v]} \big\};$
%
\\
$\sem{\exists L \in \mathcal{D}. ~\mathcal{A}}_{\lmem} = \big\{(\trsmem_1, \trsmem_2)
~|~ \exists v \in \mathcal{D}. ~ (\trsmem_1, \trsmem_2) \in \sem{\mathcal{A}}_{\lmem[L \to v]} \big\}.$
%
%
%
\paragraph{Judgment.}
The judgments are defined in following form:
\[
	\prog_1 \sim_{\epsilon} \prog_2: \Phi \Rightarrow \Psi.
\]
Here, $\prog_1$ and $\prog_2$ are programs and $\Phi$ and $\Psi$ are assertions on pairs of memories. Each assertions can refer to two copies $x\langle 1 \rangle, x\langle 2 \rangle$ of each program variable $x$, where these tagged variables refer to the value of x in the execution of $\prog_1$ and $\prog_2$ respectively.
%
\\
A judgment is valid, written $\vdash \prog_1 \sim_{\epsilon} \prog_2: \Phi_0 \Rightarrow \Phi$, 
if for any two environments $\trsmem_1$ and $\trsmem_2$ satisfying precondition $\Phi_0$, 
i.e., $(\trsmem_1, \trsmem_2) \in \sem{\Phi_0}$, there exists a lifting of $\Phi$ relating the output distributions: 
%
$(\sem{\prog_1}_{\trsmem_1})$ 
$\sem{\Phi}^{\#(\epsilon)}$ 
$(\sem{\prog_2}_{\trsmem_2})$.
%
\\
%
Fig. \ref{fig:aprhl} presents the main rules from apRHL+ \cite{barthe2016proving} excluding the while and condition rules which are not defined in out syntax, as well as the sampling rule, which we generalized in extended apRHL.
The extended rules in Fig. \ref{fig:aprhlplus} represent the lifting proved in soundness theorem.
%
\begin{figure}[ht]
\boxed{\vdash: prog \times prog \times \real \times Assert \times Assert}
{\small
\begin{mathpar}
\inferrule
{
	\empty
}
{
	\vdash
	\varx \samplel \uniform(0, 1] 	
	\sim_{\epsilon} 
	\vary \samplel \uniform(0, 1]
	:
	\top
	\Rightarrow
	\forall l, r \in [0,1]^{\real}. ~
	l \leq \varx^1 \langle 1 \rangle \leq r 
	\imply
	(e^{\epsilon} l \leq \vary^1 \langle 2 \rangle \leq e^{\epsilon}r \land \vary^1 \langle 2 \rangle \leq 1)	
}
~\textbf{Unif+}
\and
\inferrule
{
	\empty
}
{
	\vdash
	\varx \samplel \uniform(0, 1] 	
	\sim_{\epsilon} 
	\vary \samplel \uniform(0, 1]
	:
	\top
	\Rightarrow
	\forall l, r \in [0,1]^{\real}. ~
	l \leq \varx^1 \langle 1 \rangle \leq r 
	\imply
	(e^{-\epsilon} l \leq \vary^1 \langle 2 \rangle \leq e^{-\epsilon}r)
}
~\textbf{Unif-}
\and
%
\inferrule
{
\empty
}
{
	\vdash 
	\varx_1 \samplel \edistr
	\sim_{0} 
	\varx_2 \samplel \edistr
	: \top \Rightarrow 
	(\varx_2^1\langle 2 \rangle) 
	= (\varx_1^1\langle 1 \rangle )
	\land (\varx_2^2\langle 2 \rangle) = (\varx_1^2\langle 1 \rangle)
	\land (\varx_2^3\langle 2 \rangle) = (\varx_1^3\langle 1 \rangle)
}~\textbf{Null}
\and
\inferrule
{
\forall \valv. \text{ a multiple of } \Lambda
}
{
	\vdash 
	\varx_1 = \round{\vary_1}_{\Lambda}	
	\sim_{0} 
	\varx_2 = \round{\vary_2}_{\Lambda}
	: \vary_1^1 \langle 1 \rangle \lameq \valv
	\imply
	\vary_2^1 \langle 2 \rangle \lameq \valv
	\Rightarrow 
	(\varx^1_1 \langle 1 \rangle = \valv) 
	\imply (\varx^1_2 \langle 2 \rangle = \valv)
}~\textbf{Round}
\end{mathpar}
}
\caption{Rules Extended from apRHL+}
\label{fig:aprhlplus}
\end{figure}
%
\begin{figure}[ht]
\begin{mathpar}
\inferrule
{
\empty
}
{
	\vdash 
	\varx_1 = \expr_1  
	\sim_{0} 
	\varx_2 = \expr_2  
	: \Phi[\expr_1/\varx_1\langle 1 \rangle]
	[\expr_2/\varx_2\langle 2 \rangle]  \Rightarrow \Phi
}~\textbf{Assn}
~~~
\inferrule
{
\prog_1 \sim_{\epsilon} \prog_2 : \Phi_1 \Rightarrow \Phi'_1
\\
\prog'_1 \sim_{\epsilon'} \prog'_2 : \Phi'_1 \Rightarrow \Phi_2
}
{
	\vdash 
	\prog_1; \prog'_1  
	\sim_{\epsilon + \epsilon'} 
	\prog_2; \prog'_2
	: \Phi_1  \Rightarrow  \Phi_2
}~\textbf{Seq}
\and
\inferrule
{
\prog_1 \sim_{\epsilon} \prog_2 : \Phi'_1 \Rightarrow \Phi'_2
\and
\Phi_1 \Rightarrow \Phi'_1
\and 
\Phi'_2 \Rightarrow \Phi_2
\and 
\epsilon \leq \epsilon'
}
{
\prog_1 \sim_{\epsilon'} \prog_2 : 
\Phi_1 \Rightarrow \Phi_2
}~\textbf{Conseq}
\end{mathpar}
\caption{Proving Rules from apRHL}
\label{fig:aprhl}
\end{figure}
%
%
\begin{lem}[Discrete Support of Distribution]
 $\forall \prog, \trsmem, \edistr$,  s.t. $\edistr \in \distr(Env)$ and $\sem{\prog}_{\trsmem} = \edistr$. Then $\supp{(\edistr)}$ is discrete.
\end{lem}
%
\begin{proof}
By induction on $\prog$, we have the proof of this Lemma in detailed versions.
\end{proof}
%
%
\begin{thm}[Soundness]
 $\forall \prog_1$, $\prog_2$,  $ \vdash \prog_1	
\sim_{\epsilon} 
\prog_2 :
\Phi_0 \Rightarrow \Phi $,    $\forall \trsmem_1$, $\trsmem_2$ 
s.t $\Phi_0$: 
$\trsmem_1 ~ \sem{\Phi_0} ~ \trsmem_2$,
then
$$ 
(\sem{\prog_1}_{\trsmem_1})  
\sem{\Phi}^{\#(\epsilon)} 
(\sem{\prog_2}_{\trsmem_2}) 
$$.
\end{thm}
%
%
%
\begin{proof}
By induction on the judgment $\vdash \prog_1	
\sim_{\epsilon}
\prog_2 :
\Phi_0 \Rightarrow \Phi $,  we have the proof of this Lemma in detailed versions.
\end{proof}
%
%
\begin{thm}
\label{thm:unif+_coupling}
%
$${\muniform(0,1]} ~ R^{\#(\epsilon)} ~ {\muniform(0,1]},$$
%
where
	$	R = 
		\left \{(\varx, \vary) \in {\float} \times {\float} 
		~|~
		\forall \rvalL, \rvalR \in [0,1]^{\real}. ~
		\rvalL \leq \varx \leq \rvalR
		\imply
		(e^{\epsilon} \rvalL \leq \vary \leq 	e^{\epsilon} \rvalR
		\land \vary \leq 1)
		\right \}
		$.
	%
\end{thm}
%
\begin{proof}[Proof of Theorem \ref{thm:unif+_coupling} seen in full version]
%
\end{proof}
%
%
\begin{thm}
\label{thm:unif-_coupling}
$${\muniform(0,1]} ~ R^{\#(\epsilon)} ~ {\muniform(0,1]},$$
%
where
	$R = 
		\left \{(\fval_1, \fval_2) \in {\float} \times {\float} 
		~|~
		\forall \rvalL, \rvalR \in (0,1]^{\real}.
		(\rvalL \leq \fval_1 \leq \rvalR
				\imply
				e^{-\epsilon} \rvalL \leq \fval_2 \leq 	e^{-\epsilon} \rvalR)
		\right \}	
		$.
	%
\end{thm}
%
\begin{proof}[Proof of Theorem \ref{thm:unif-_coupling} seen in full version]
%
\end{proof}
%
%
%
%
\newpage
\section{Examples}

\begin{defn}
[Snapping Mechanism: $\snap(a) : A \to \distr(\real)$]
Given privacy parameter $\epsilon$, the Snapping mechanism $\snap(a)$ is defined as:
\[
	\varu \samplel \uniform(0,1); s \samplel \uniform\{-1, 1\};
	\varx = f(a) + \frac{1}{\epsilon} \times s \times \ln (\varu);
	\vary = \round{\varx}_{\Lambda};
	\varz = \clamp_B (\vary)
\]
where $f(a)$ represents a value that the query function $f$ be evaluated over input database $a \in A$, $\epsilon$ is the privacy parameter, $B$ is the clamping argument and $\Lambda$ is the rounding argument satisfying $\lambda = 2^k$ where $2^k$ is the smallest power of 2 greater or equal to the $\frac{1}{\epsilon}$.
\end{defn}
%
\begin{thm}[The $\snap$ mechanism is 
$\epsilon-$differentially private]
\end{thm}
\begin{proof}[seen in full version]
\end{proof}

\newpage
\bibliographystyle{plain}
\bibliography{verifysnap.bib}

\end{document}



